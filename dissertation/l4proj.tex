\documentclass{l4proj}

\input{semmacros}
\usepackage{amsmath, amssymb}

\SetKwRepeat{Do}{do}{while}
\SetKwProg{Fn}{Function}{:}{end}


\begin{document}

%===================================================================================================

\title{Boolean types and semantic subtyping for Featherweight Java}
\author{Artem Usov}
\date{January 18, 2020}

\maketitle

%===================================================================================================

\begin{abstract}
    Every abstract follows a similar pattern. Motivate; set aims; describe work; explain results.
    \vskip 0.5em
    ``XYZ is bad. This project investigated ABC to determine if it was better.
    ABC used XXX and YYY to implement ZZZ. This is particularly interesting as XXX and YYY have
    never been used together. It was found that
    ABC was 20\% better than XYZ, though it caused rabies in half of subjects.''
\end{abstract}

%===================================================================================================

\def\consentname {Artem Usov}
\def\consentdate {19 January 2020}
\educationalconsent

%===================================================================================================

\tableofcontents

%===================================================================================================

\chapter{Introduction}

\pagenumbering{arabic}

\section{End goal of programming}

The end goal in all programming projects is to create a solution to the task at hand that exactly solves the initially defined problem and performs exactly as expected by the programmer.
However, this very rarely actually happens.

On the one hand, this is often because the original problem is not statically defined.
If, for example, it is a solution for an external client, then their requirements and needs will change over time.
This means the project needs to be adapted over time.
On the other hand, and almost always much less evident, is that programs do not work exactly as the programmer imagines them to work.

In general these are called \emph{bugs} in a program, and have become more and more common as projects and the underlying hardware they run on have become more complex since the early days of computing.
Therefore in both academia and industry there have been great efforts over the years to create tools that allow us to decrease the amount of bugs in our programs and increase our productivity.

\subsection{Static Code Analysis}

One area of great effort has been in the development of static code analysis tools.
Some of these exist integrated into the language itself such as with Spark \citep{Carre1990}.
Spark is a formally defined language based on the Ada \citep{Ada1979} language intended for the development of high integrity software such as flight control systems.
Others exist as separate, well-known tools that exist alongside the language such as the Clang analysis tools for C and C++. \footnote{https://clang.llvm.org/docs/ClangTools.html}

Whilst they are not necessarily needed to write correct programs, these tools have quickly become industry standards for maintaining a level of correctness within codebases and avoiding typical programming errors.

\subsection{How static analysis works}

Underlying how all of the previously mentioned static code analysis tools work, is through their use of the \emph{type system} of the language.
Type systems at their most basic work by assigning types to various constructs of a program so that incompatible types cannot be used.

For example, one common area of error in C code that the Clang tools warn about is implicit conversions, where the value of an expression is a different type from the one expected, such as the use of a floating point number where an integer is expected.
The C language will implicitly convert the value to an integer, however this happens unbeknownst to the programmer, which can cause unexpected behaviour later on in the program.
The tools, using the same knowledge that you can only use an integer where an integer is expected, can therefore flag this as being a potential bug.

\section{Varying Type Systems}

The effectiveness of static analysis tools and more generally the \emph{safety} and \emph{expressivity} of a programming language therefore depends on the type system that is used.
Type systems have evolved from the relatively simple systems in languages like C to more complex ones such as in Java which have class types and subtyping relations where types can be substituted for one another.

More modern advances in type systems include the use of linear types in the Cyclone \citep{grossman2002} language that allow us to more naturally and logically define finite state machines.
There also exist other new developments in type systems such as Boolean types which are explored in this paper.

\section{Goals of this Project}

In this section, the issues and aims of this paper are presented.

\subsection{Problem Statement}

The typical hierarchical subtyping definitions in Java quite often restrict and complicate the logic that the programmer wants to implement.
These problems come up particularly often when working with legacy code that has incorrectly defined abstractions in its classes.
This therefore leads to less understandable and less maintainable code that could cause problems in the future.

\subsection{Aims}

The aim of this project is to implement a new programming language, which we further call Semantic Featherweight Java (SFJ), which uses a new proposed type system consisting of a semantic subtyping algorithm, which is based on set-theoretic models, and boolean type connectives such as: \emph{and}, \emph{or} and \emph{not}.

While there is some non-trivial mathematical machinery involved in implementing such a type system, once it is implemented, this more powerful type system can be used by programmers without knowledge of the implementation underneath.

This project aims to transform the mathematical definition of such a type system by \citet{Dardha2017} into an actual software implementation, solving the issues encountered doing so.
The language should be able to illustrate improved solutions to the example problems which are encountered in a language without these features such as Java.
Furthermore, the language will be evaluated so see whether these additional language features are intuitive to use.

\section{Dissertation Outline}

The dissertation is structured into seven chapters as follow:

\begin{itemize}
    \item
          \textbf{Chapter 2} provides background about type systems and Featherweight Java, the language on top of which the new type system is implemented.
          We also discuss the tools which were used in this project and existing work on semantic type systems and boolean types.
    \item
          \textbf{Chapter 3} introduces the design a    nd implementation of SFJ. This includes the syntax of the language, and the key algorithms which were used to implement the type system.
    \item
          \textbf{Chapter 4} TODO
    \item
          \textbf{Chapter 5} TODO
    \item
          \textbf{Chapter 6} contains details about the evaluation method, evaluation results and analysis of results.
    \item
          Finally \textbf{chapter 7} concludes the dissertation with a summary of the important results.
\end{itemize}

%===================================================================================================

\chapter{Background}

In this chapter, we define and explore type systems and the different ways they can be defined. We especially explore the semantic method of defining a type system and explore the benefits and challenges that it brings. We also discuss the tools that were used in this project and the related work that has already been done with boolean types or semantic type systems.

\section{Type Systems}

In all modern programming languages, a \emph{type system} is arguably the main way that incorrect behaviour in a program is reduced by preventing the occurrence of \emph{type errors}.
A possible definition of a type system is given by \citet{Pierce2002} as:

\emph{A type system is a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute.}

A type error is defined by \citet{wright1994} as:

\emph{The use of a function on arguments for which it is not defined, and the attempted application of a non-function.}

Most importantly, we want to emphasize from the first definition that in a type system, we aim to classify phrases in our language into a specific \emph{type}.
Then, using the type system, we can check that the types of the arguments given to any operation are always correct, thus avoiding a type error.

For example, taking the addition operation which takes two arguments of the number type, then given the arguments $42$ and $2 + 2$, we know they both hold or compute a number type and so there is guaranteed to be no type error.
Conversely, given the arguments $42$ and the boolean value $true$, they are not both a number type and so cause a type error.
We therefore avoid unexpected bad run-time behaviour and instead find these problems before even running the program.

However what the first definition is missing is that it defines a type system to be solely a syntactic method, in which the system is defined as a list of formal deduction rules.
The syntactic approach is certainly by far the most common approach for a type system, but there does exist an alternative method in the semantic approach.
\citet{Frisch2002} describe the semantic approach as instead starting with a model of the language and all the possible values in the language and defining an interpretation of types as subsets of values the model.

For example, given a language with a model $D$:

\begin{equation*}
    D = \left[ a + bi \mid a, b \in \mathbb{R}\right]
\end{equation*}

we can define the types \emph{int}, \emph{real} and \emph{complex} as subsets of the values in $D$ corresponding to their usual mathematical definitions.

Such as model comes with several advantages.
For example, given two types $s$ and $t$, which represent subsets of values in the model, when $s \subseteq t$ does not hold, it is possible to exhibit an element of the model which is in the interpretation of type $s$ and not $t$.
This can then be used to show more informative error messages to the programmer as shown by \citet{Castagna2005}, such as showing which value in $s$ is causing the equality not to hold.
Secondly the set based approach to the type system leads itself to able to incorporate boolean operators into its types easily.
However due to being a more technical approach, such as the non-triviality of defining the interpretation of types as subsets of a model as discussed below, the semantic method has received less attention than syntactic methods.

The first problem we encounter in the semantic approach is that in such a model, $t_{1}$ is a subtype of $t_{2}$ if all the $t_{1}$-values are also $t_{2}$-values, i.e. the equality $t_{1} \subseteq t_{2}$ holds.
However, in this way, subtyping is defined by relying on the notion of well-typed values; hence, we need the typing relation to able to type values; but the typing rules require a subtyping relation to be fully defined.
So, there is a circularity in our definition, as demonstrated in Figure \ref{fig:circ}.

To solve this problem, we follow the framework defined by \citet{Frisch2008}.
The general idea of the framework is that we first extend the types in the language with \emph{Boolean Combinators}: union $\lor$, intersection $\land$ and negation $\neg$ to give a type algebra $\tau$.
We can then define an abstract model $\beta$ with a interpretation function $[\![ ]\!]_{\beta} : \tau \to \rho(\beta)$ (where $\rho(\beta)$ is the power-set of $\beta$).
This model must capture the meaning of each type but also interprets the combinators in a set-theoretic way, such as $[\![s \land t]\!]_{\beta} = [\![s]\!]_{\beta} \cap [\![t]\!]_{\beta}$ etc.
This model then induces the following subtyping relation:

\begin{equation*}
    s \leq_{\beta} t \iff [\![s]\!]_{\beta} \subseteq [\![t]\!]_{\beta}
\end{equation*}

and we can therefore define the typing rules.

Separately, now that we have typing rules, we can define a new interpretation of types based on values $[\![t]\!]_{\mathrm{v}} = \left\{\mathrm{v} \in V \mid \: \vdash_{\beta} \mathrm{v} : t \right\}$ and then define a ``new''subtyping relation as above:

\begin{equation*}
    s \leq_{\mathrm{v}} t \iff [\![s]\!]_{\mathrm{v}} \subseteq [\![t]\!]_{\mathrm{v}}
\end{equation*}

While these may be different relations, if the models are chosen carefully such that:
\begin{equation*}
    s \leq_{\beta} t \iff s \leq_{\nu} t,
\end{equation*}

then these subtyping relations coincide and this closes the circularity.

\begin{figure}
    \centering
    \includegraphics[width=0.4\linewidth]{images/circularity.PNG}
    \caption{Circularity in the semantic subtyping definition \citep{Castagna2005}}
    \label{fig:circ}
\end{figure}

\section{Nominal vs Structural Subtyping}

Orthogonally to the discussion above of syntactic versus semantic approaches, for object-oriented languages such as SFJ, there also exists two other opposing approaches to defining a subtyping relation: the \emph{nominal} and \emph{structural} approaches.

Nominal subtyping is based on explicit declarations by the developer of the class-hierarchy and is the approach used in Java. $A$ is a subtype of $B$ if and only if it declared to be so by including an explicit declaration that $A$ extends $B$. In Java, every user-defined class either extends another user-defined class or extends the root $Object$ class, creating a tree-like subtyping hierarchy.

Structural subtyping uses the structure of classes, namely its fields and methods, to define the subtyping relation. $A$ is a subtype of $B$ if and only if the fields and methods of $B$ are a subset of the fields and methods of $A$, and that field and method return types are covariant and the method argument types are contravariant. This is similar to the requirements in Liskov's substitution principle \citep{Liskov1994} without the behavioural conditions.

$$
    \begin{array}{ll}
        \syndecl{Apple}{\mathit{Object}} {
         &
            \qquad
            \syndecl{Steel}{\mathit{Object}} {
                \\
                \qquad\quad \mathbf{float}\ \mathit{setPrice}\ (\mathbf{int}\ a)\{\ \ldots\ \}\qquad
         &
                \qquad\qquad\quad \mathbf{int}\ \mathit{quality}\
                \\
            }
            \qquad\quad\qquad
         &
            \qquad\qquad\quad \mathbf{int}\ \mathit{setPrice}\ (\mathbf{float}\ a)\{\ \ldots\ \}
            \\
         &
            \qquad }
    \end{array}
$$

We can see in the example above that $Steel$ is a structural subtype of $Apple$, as we can see that the use of any field or method of $Apple$ would also be valid for an object of type $Steel$. Similarly any field or method return types in $Steel$ are the same or less generic than in $Apple$, and any method argument types are the same or more generic in $Steel$ than in $Apple$. However, $Apple$ is not a subtype of $Steel$ as $Apple$ is missing the $quality$ field. However in some cases a pair of classes can both be subtypes of one another.

Nominal subtyping is more popular than structural subtyping, which makes it perhaps unsurprising that nominal subtyping aligns well with the syntactic approach, and structural subtyping aligns well with the semantic approach.

In our implementation of SFJ based on the work of \citet{Dardha2017, Dardha2013}, we implement a semantic type system however we include both nominal and structural subtyping as we will further show that this approach gives the programmer a choice in which approach he may wish to use, but also allows greater flexibility and compactness for the logic a programmer may wish to implement.

\section{Featherweight Java}

The syntax of SFJ is exactly that of Featherweight Java (FJ) \citep{Igarashi1999}, with only the associated type system being different.
FJ is closely related to Java, with a key simplification in the removal of assignment operators.
All fields of an object cannot be changed after initialisation and all methods are pure functions.
While this restricts FJ to what is essentially a functional fragment of Java, it is still fully computationally complete.
SFJ was intentionally based on FJ instead of the full Java language because features such as concurrency and reflection are orthogonal to the purpose of demonstrating the implementation of our novel semantic type system.

\paragraph{Multimethods}
While FJ removes some feature of the full Java language, the introduction of boolean types and semantic subtyping restores some of these for free.
Overloaded methods is one of these.
As suggested by \citet{Dardha2017}, we can thus model \emph{multimethods} \citep{BC97}, which according to the authors is ``\emph{very clean and easy to understand [...] it would be the best solution for a brand new language}".
As an example \citet{Dardha2013,Dardha2017} consider the following class declarations:

$$
    \begin{array}{ll}
        \syndecl{A}{\mathit{Object}} {
         &
            \qquad
            \syndecl{B}{A} {
                \\
                \qquad\quad \mathbf{int}\ \mathit{length}\ (\mathbf{string}\ s)\{\ \ldots\ \}\qquad
         &
                \qquad\qquad\quad \mathbf{int}\ \mathit{length}\ (\mathbf{int}\ n)\{\ \ldots\ \}
                \\
            }
         &
            \qquad }
    \end{array}
$$

Method {\it length} has type $\mathbf{string} \rightarrow \mathbf{int}$ in $A$. However, in $B$ it has type $(\mathbf{string} \rightarrow \mathbf{int}) \synwedge (\mathbf{int} \rightarrow \mathbf{int})$,
which can be simplified as $(\mathbf{string} \synvee \mathbf{int}) \rightarrow \mathbf{int}$.


\section{Tools}

The type system of FSJ was built using ANTLR \citep{parr2013} to define the grammar of the language and automatically create a parser for this grammar rather than having to create one by hand, which made the initial development process much quicker.
It accepts a grammar using Extended Backus-Naur Form (EBNF) \footnote{See ISO/IEC 14977 for reference, although it is not the standard used in the examples} notation to create ANTLR rules which are a list of productions or alternatives.
A general form of a rule is as follow:

$$
    \begin{array}{llll}
        rule & : & alternative_{1}
        \\
             & | & alternative_{2}
        \\
             &   & \vdots
        \\
             & | & alternative_{n}
        \\
             & ; &
    \end{array}
$$

Each alternative production in a rule can itself be a list of elements, where an element can be another rule or just a terminating token.
Since we are using EBNF notation, we can also use \emph{*} and \emph{?} to respectively signify repeated and conditional elements in a production.
We can also use $|$ to give several alternatives for a single element.
We show an excerpt taken from the SFJ grammar as an example:

$$
    \begin{array}{llll}
        expression     & : & \mbox{primExpression ( (PLUS | MINUS | DIV | MULT) primExpression)?}
        \\
                       & ;
        \\
        \\
        primExpression & : & \mbox{NUMBER}
        \\
                       & | & \mbox{TRUE}
        \\
                       & ; &
        \\
        \\
        TRUE           & : & \mbox{'true'}
        \\
                       & ; &
        \\
        \\
        NUMBER         & : & \mbox{DIGIT (DIGIT)*}
        \\
                       & ; &
        \\
        \\
        DIGIT          & : & '0'..'9'
        \\
                       & ; &
    \end{array}
$$

\section{Related Work}
The closest similar area of research would likely be the work on $\mathbb{C}$Duce
\citep{Benzaken2003}, which is xalso a functional language with a semantic type system designed for
working with XML documents and a continuation of the work on XDuce \citep{Hosoya2003}. The language
extended XDuce by introducing less XML specific types such as records, boolean connectives and arrow
types. This therefore makes it similar to (\textit{TODO reword}) our language in that a class-based
semantic type system is a combination of the $\mathbb{C}$Duce record types with arrow types
\textit{(fields and methods)}

Our work and the work on $\mathbb{C}$Duce follow the functional style of $\lambda$-calculus,
whereas the work by \citet{Castagna2008} extends $\pi$-calculus with semantic subtyping.
(\textit{TODO reword}) Similar work to ours creating an implementation for this would result in a
Golang-like \footnote{https://golang.org/} like language, creating a concurrency-focused language with more
intuitive types. The paper found that it was required to be able to decide and resolve the atomicy,
that is whether the only proper subtype is the empty type, of types in order to decide the subtyping
relation, and observes that this same problem appears in $\lambda$-calculus and any other
semantic-based system, for which we will show where we encountered this problem further in this
paper.

%===================================================================================================

% \chapter{Analysis/Requirements}
% What is the problem that you want to solve, and how did you arrive at it?
% \section{Guidance}
% Make it clear how you derived the constrained form of your problem via a clear and logical process.

%===================================================================================================
\chapter{SFJ: Design and Implementation}

\section{Syntax}

\subsection{Syntax of Types}

\label{sec:design}
The syntax of types is given by the following grammar \citep{Dardha2013,Dardha2017}:
$$
    \begin{array}{llll}
        \tau   & ::=                                       & \alpha \ |\ \mu
               & \mbox{{\em Type term}}
        \\
        \alpha & ::=                                       & \zero \ |\ \btypes \ |\ [\wt{l:\tau}] \ |\ \alpha \ \bf{and}\ \alpha \ |\ \bf{not}\ \alpha
        \qquad
               & \mbox{{\em Object type} ($\alpha $-type)}
        \\
        \mu    & ::=                                       & \alpha \to \alpha \ |\ \mu \ \bf{and}\ \mu \ |\ \bf{not}\ \mu
               & \mbox{{\em Method type} ($\mu $-type)}
    \end{array}
$$

$\alpha$-types are used to type fields and $\mu$-types are used to type methods.
Type $\zero$ is the empty type.
Type $\btypes$ denotes the \emph{basic} types, such as integers, booleans, etc.
    {Record} types $[\wt{l:\tau}]$, where $\wt l$ is a sequence of disjoint labels are used to type objects.
Arrow types $\alpha \to \alpha$ are used to type methods.
The boolean types using ${and}$ and ${not}$ have their expected set-theoretic meanings, and ${or}$ is obtained by their combination.\\

\subsection{Syntax of Terms}

The syntax of terms is given by the following grammar and is based on the standard syntax of terms in FJ \cite{Igarashi1999,Dardha2013,Dardha2017}.

We assume an infinite countable set of names, with some special names: $\mathit{Object}$ indicates the root class, $\synthis$  indicates the current and $\synsuper$ indicates the parent object.
We let  $A, B, C, \ldots$ range over classes; $a, b, \ldots$ over fields; $m, n, \ldots$ over methods and $x, y, z, \ldots$ range over variables.

\begin{align*}
     & \mbox{\textit{Class declaration}}  & L \; ::= \; & \syndecl{C}{C}{\wt{\alpha \ a};\ K; \ \wt{M}\ }                         \\
     & \mbox{\textit{Constructor}}        & K \;::=\;   & C\ (\wt{\alpha\ x})\ \{\ \synsuper(\wt{x});\ \wt{\synthis.a}=\wt{x}; \} \\
     & \mbox{\textit{Method declaration}} & M \; ::= \; & \alpha \ m\ (\alpha \ x)\ \{\ \synret e; \}                             \\
     & \mbox{\textit{Expressions}}        & e \; ::=\;  & x\ |\ e.a\ |\ e.m(e) \ | \ \synnew C(\wt{e})
\end{align*}

A {program} $(\wt{L}, e)$ consists of a sequence of class declarations $\wt L$ and an expression $e$ to be evaluated.

A class declaration $L$ specifies the name of the class, the name of the parent class it extends, its typed fields , the constructor $K$ and its method declarations $M$.
The constructor $K$ initializes the fields of the object by assigning values to the fields inherited by the super-class and to the fields declared in the current \textbf{this} class.
A method declaration $M$ specifies the signature of the method, namely the return type, the method name and the formal parameter as well as the body of the method. Expressions $e$ include variables, constants, field accesses, method invocations and object creations.

In the theoretical development by \citet{Dardha2017}, unary methods are used without loss of generality: tuples of arguments can be modelled by an object that instantiates a ``special''class containing as fields all the needed arguments.

We include the translation of the syntax of term into the ANTLR grammar for SFJ in Appendix \ref{lst:sfjgram}.

\section{Implementation}

\subsection{Finite Types}

Since we want to use types $\tau$ in practice in SFJ, we restrict them to finite trees whose leaves are basic types with no cycles.
For example, a recursive type $A = [a : A]$ denotes an infinite program tree \textbf{new} ${A}$(\textbf{new} $A$($\cdots{}$)), hence we avoid it as it is uninhabitable.
Similarly the types $A = [b: B]$, $B = [a = A]$ create a cycle in our program tree and would also be impossible to instantiate.

These kind of type definitions are allowed but still inhabitable in Java since you can always instantiate a object of any type by assigning the value $null$ to it.
However, since we restrict ourselves to the functional fragment of Java, we do not allow this.

Given a SFJ program, we use the ANTLR grammar to create a parser for our language and run this parser on the program to give us an abstract syntax tree (AST).
When processing the AST of a program in SFJ, we forbid fields to have the same type as the type of the class they are defined in.
Secondly, we mark any classes containing fields typed with only basic types as \emph{resolved} otherwise, as \emph{unresolved}.
This is then used by Algorithm \ref{alg:types}, which checks if the type definitions in the program are valid.

\begin{algorithm}
    \DontPrintSemicolon
    \KwData{$classes$, a set of classes, each marked as resolved or unresolved depending on if their fields contain only basic types}
    \KwResult{$True$ if classes are all valid type definitions, $False$ if not.}
    \Begin{
        \Do{$resolutionOccured = true$}{
            $resolutionOccured \longleftarrow false$ \;
            \For{class that is unresolved in classes}{
                $resolved \longleftarrow true$ \;
                \For{field in class that contains a class type}{
                    \For{type in field that is a class type}{
                        \If{type is unresolved}{
                            $resolved \longleftarrow false$
                        }
                    }
                }
                \;
                \If{$resolved = true$}{
                    $class \longleftarrow resolved$ \;
                    $resolutionOccured \longleftarrow true$ \;
                }
            }
        }
        \;
        \uIf{all classes are not resolved}{
            \KwRet $False$
        }
        \Else{
            \KwRet $True$
        }
    }

\caption{Algorithm for given a set of classes which are marked as resolved or unresolved, determines if all the classes can be resolved, i.e. if all the types are finite trees with no cycles and with basic types as leaves}
\label{alg:types}
\end{algorithm}

If the types in the program are finite trees whose leaves are constants with no cycles, then at each iteration of the algorithm we are going to be able to resolve at least one type or all the types are going to be resolved.
If we do not resolve at least one type and not all types are resolved, we know we have encountered a cycle in the type definition.

\subsection{Defining the subtyping relation}

Now, given that we know that the class type definitions in our program are valid, we can define the subtyping relation for this program.

Building upon the interpretation of types as sets of values, we define the subtyping relation by defining a map from a type to the set of its subtypes, with the property that the set of values of a subtype is included in the set of values of the type.
As a first step, we start with basic types.

\begin{flalign}
    \label{fig:initialSubtype}
    &Double  = \left\{Double, Float, Int, Short, Byte\right\} &&Float = \left\{Float, Short, Byte\right\}\\
    &Long = \left\{Long, Int, Short, Byte\right\}  &&Int = \left\{Int, Short, Byte\right\}\\
    &Short = \left\{Short, Byte\right\} && Byte = \left\{Byte\right\}\\
    &Boolean = \left\{Boolean \right\}
\end{flalign}

We would like to note that \emph{Int} is not a subtype of \emph{Float}, as by the definition of floating-point numbers in Java \footnote{See IEEE-754 for reference}, \emph{Float} only has 23 bits for the mantissa, meaning it cannot represent all possible values of a 32 bit \emph{Int} accurately and therefore \emph{Int} is not fully set-contained. However, this is not the case for \emph{Int} and \emph{Double} as the latter has a 52 bit mantissa. This is also why \emph{Long} is not a subtype of \emph{Double}.

Finally, Algorithm \ref{alg:subtyping} defines the subtyping relation for all class types, which concludes the process.

\begin{algorithm}
    \DontPrintSemicolon
    \KwData{
        $classes$, \;

        $relation$, a map of types to the set of its subtypes.\ref{fig:initialSubtype}
    }

    \Begin{
        \Fn{generateRelation(classes: List<Class>)}{
            $untyped: List<Class>\ \longleftarrow []$

            \For{class in classes}{
                \If{addClass(class) = $False$}{
                    $untyped.add(class)$
                }
            }
            \If{$untyped \neq []$}{
                $generateRelation(untyped)$
            }
        }
        \;
        \Fn{addClass(class: Class) $\rightarrow$ boolean}{
            \For{existing class type in relation}{
                \If{checkSuperSet(class, existingClass) = false}{
                    \KwRet $False$\;
                }
                $checkSuperSet(existingClass, class)$\;
            }
            $relation[class].add(class)$ \;
            \KwRet $True$ \;
        }
        \;
        \Fn{checkSuperSet(class: Class, other: Class) $\rightarrow$ boolean}{
            $flag \longleftarrow True$ \;
            \;
            \For{field in class}{
                \If{field contains type not in relation}{
                    \KwRet $False$
                }
                \uIf{other does not contain field}{
                    $flag \longleftarrow False$
                }
                \Else{
                    \If{other.field.types does not fully contain field.types}{
                        $flag \longleftarrow False$
                    }
                }
            }
            \;
            \For{method in class}{
                \If{method contains type not in relation}{
                    \KwRet $False$
                }
                \uIf{other does not contain method}{
                    $flag \longleftarrow False$
                }
                \Else{
                    \If{other.method.types does not fully contain method.types}{
                        $flag \longleftarrow False$
                    }
                }
            }
            \;
            \If{$flag = True$}{
                $relation[other].add$
            }
        }
    }

\caption{Recursive algorithm for creating a semantic subtyping relation, given a set of class types that are finite trees and the initial relation for basic types. Given that we know all classes are valid types, we are guaranteed it will terminate}
\label{alg:subtyping}
\end{algorithm}

%===================================================================================================

\chapter{Implementation}

What did you do to implement this idea, and what technical achievements did you make?

\section{Guidance}
You can't talk about everything. Cover the high level first, then cover important, relevant or impressive details.

\section{General points}

These points apply to the whole dissertation, not just this chapter.

\subsection{Figures}

\emph{Always} refer to figures included, like Figure \ref{fig:relu}, in the body of the text. Include full, explanatory captions and make sure the figures look good on the page.
You may include multiple figures in one float, as in Figure, using \texttt{subcaption}, which is enabled in the template.

\subsection{Equations}

Equations should be typeset correctly and precisely. Make sure you get parenthesis sizing correct, and punctuate equations correctly
(the comma is important and goes \textit{inside} the equation block). Explain any symbols used clearly if not defined earlier.

For example, we might define:
\begin{equation}
    \hat{f}(\xi) = \frac{1}{2}\left[ \int_{-\infty}^{\infty} f(x) e^{2\pi i x \xi} \right],
\end{equation}
where $\hat{f}(\xi)$ is the Fourier transform of the time domain signal $f(x)$.

\subsection{Algorithms}

Algorithms can be set using \texttt{algorithm2e}, as in Algorithm.

\subsection{Tables}

If you need to include tables, like Table , use a tool like https://www.tablesgenerator.com/ to generate the table as it is extremely tedious otherwise.

\subsection{Code}

Avoid putting large blocks of code in the report (more than a page in one block, for example). Use syntax highlighting if possible, as in Listing.

%===================================================================================================

\chapter{Evaluation}
How good is your solution? How well did you solve the general problem, and what evidence do you have to support that?

\section{Guidance}

\begin{itemize}
    \item
          Ask specific questions that address the general problem.
    \item
          Answer them with precise evidence (graphs, numbers, statistical
          analysis, qualitative analysis).
    \item
          Be fair and be scientific.
    \item
          The key thing is to show that you know how to evaluate your work, not
          that your work is the most amazing product ever.
\end{itemize}

\section{Evidence}
Make sure you present your evidence well. Use appropriate visualisations, reporting techniques and statistical analysis, as appropriate.

If you visualise, follow the basic rules, as illustrated in Figure:
\begin{itemize}
    \item Label everything correctly (axis, title, units).
    \item Caption thoroughly.
    \item Reference in text.
    \item \textbf{Include appropriate display of uncertainty (e.g. error bars, Box plot)}
    \item Minimize clutter.
\end{itemize}

See the file \texttt{guide\_to\_visualising.pdf} for further information and guidance.


%===================================================================================================

\chapter{Conclusion}

Summarise the whole project for a lazy reader who didn't read the rest (e.g. a prize-awarding committee).

\section{Guidance}
\begin{itemize}
    \item
          Summarise briefly and fairly.
    \item
          You should be addressing the general problem you introduced in the
          Introduction.
    \item
          Include summary of concrete results (``the new compiler ran 2x
          faster'')
    \item
          Indicate what future work could be done, but remember: \textbf{you
              won't get credit for things you haven't done}.
\end{itemize}

%===================================================================================================

%  APPENDICES

\begin{appendices}


    \chapter{SFJ ANTLR Grammar}

    \begin{lstlisting}[label={lst:sfjgram}, caption={The full ANTLR grammar for SFJ language}]
        grammar sfj;

        program
                :       classDecl* expression EOF
                ;

        classDecl
                :   CLASS classlbl=ID (EXTEND extendlbl=ID)? LBRAC
                        fieldDecl* constructorDecl methodDecl*
                    RBRAC
                ;

        fieldDecl
                :       type ID SEMI
                ;

        constructorDecl
                :       constructorname=ID LPAR (type ID (COMMA type ID)*)? RPAR LBRAC
                            superDecl
                            fieldAssignment*
                        RBRAC
                ;

        superDecl
                :       SUPER LPAR (ID (COMMA ID)*)? RPAR SEMI
                ;

        fieldAssignment
                :       THIS DOT field=ID EQ parameter=ID SEMI
                ;

        methodDecl
                :       returntype=type name=ID LPAR (paramtype=methodType paramname=ID)? RPAR LBRAC
                            RETURN expression SEMI
                        RBRAC
                ;

        expression
                :       e1=primExpression
                            (op=(PLUS | MINUS | DIV | MULT) e2=primExpression)?
                ;

        primExpression
                :       NUMBER
                |       DECIMAL
                |       TRUE
                |       FALSE
                |       ID
                |       THIS
                |       primExpression DOT ID
                |       primExpression DOT ID LPAR (expression)? RPAR
                |       NEW ID LPAR (expression (COMMA expression)*)? RPAR
                ;

        type
                :       basicType
                |       ID
                |       NOT classlbl=type
                |       LPAR type1=type bool=(AND | OR) type2=type RPAR
                ;

        basicType
                :       BYTE | INT | LONG | FLOAT | DOUBLE | CHAR | BOOL
                ;

        methodType
                : type
                | LPAR (NOT)? ID COLON param=type ARROW returnType=type RPAR
                ;


        BYTE    :       'byte'                      ;
        INT     :       'int'                       ;
        LONG    :       'long'                      ;
        FLOAT   :       'float'                     ;
        DOUBLE  :       'double'                    ;
        CHAR    :       'char'                      ;
        BOOL    :       'bool'                      ;

        TRUE    :       'true'                      ;
        FALSE   :       'false'                     ;

        AND     :       'and'                       ;
        OR      :       'or'                        ;
        NOT     :       'not'                       ;

        CLASS   :       'class'                     ;
        SUPER   :       'super'                     ;
        EXTEND  :       'extends'                   ;
        THIS    :       'this'                      ;
        RETURN  :       'return'                    ;
        NEW     :       'new'                       ;

        LPAR    :       '('                         ;
        RPAR    :       ')'                         ;
        LBRAC   :       '{'                         ;
        RBRAC   :       '}'                         ;
        EQ      :       '='                         ;
        PLUS    :       '+'                         ;
        MINUS   :       '-'                         ;
        DIV     :       '/'                         ;
        MULT    :       '*'                         ;
        COMMA   :       ','                         ;
        DOT     :       '.'                         ;
        SEMI    :       ';'                         ;
        COLON   :       ':'                         ;
        ARROW   :       '->'                        ;

        ID      :       LETTER (LETTER | DIGIT)*    ;
        NUMBER  :       DIGIT (DIGIT)*              ;
        DECIMAL :       DIGIT DOT (DIGIT)*          ;
        SPACE   :       (' ' | '\t')+   -> skip     ;
        EOL     :       '\r'? '\n'      -> skip     ;
        EMPTY   :       'EMPTY'                     ;

        fragment LETTER :   'a'..'z' | 'A'..'Z'     ;
        fragment DIGIT  :   '0'..'9'                ;
    \end{lstlisting}

    \chapter{TODO}

\end{appendices}

%===================================================================================================

\bibliographystyle{abbrvnat}

\bibliography{l4proj}

\end{document}
