\documentclass[runningheads]{llncs}
%%%%%%%%%%%%%%%%%%%%%%%%
%PACKAGES
%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
%\usepackage{marvosym}
%\usepackage{txfonts}
%\usepackage{multicol}
\usepackage{proof-dashed}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{stmaryrd}

\addto\extrasenglish{%
  \renewcommand{\sectionautorefname}{\S}%
}

\makeatletter
\def\verbatim@font{\linespread{0.75}\normalfont\ttfamily}
\makeatother

% Non standard
%\usepackage{varacca}
\input semmacros

\begin{document}

\title{SFJ: An implementation of Semantic Featherweight Java\thanks{Research supported by the UK EPSRC grant EP/K034413/1, ``From Data Types to Session Types: A Basis for Concurrency and Distribution (ABCD)'', and by the EU HORIZON 2020 MSCA RISE project 778233 ``BehAPI: Behavioural Application Program Interfaces''.}}
\titlerunning{SFJ}

\author{Artem Usov \and Ornela Dardha\orcidID{0000-0001-9927-7875}}
\authorrunning{A. Usov and O. Dardha}

\institute{School of Computing Science, University of Glasgow, United Kingdom \\
    \email{\{artem.usov, ornela.dardha\}@glasgow.ac.uk}}

\maketitle

\begin{abstract}
Subtyping is a key notion in programming languages, as it allows more flexibility in coding.
There are two approaches to defining subtyping relations: the \emph{syntactic} and the \emph{semantic} approach.
In the latter, one starts by defining a model of the programming language at hand and an interpretation of its types as subsets of such model.
Then, subtyping is defined as \emph{set inclusion of types} denoting sets.
An orthogonal issue, typical of object-oriented languages, is the \emph{nominal} and \emph{structural} subtyping.
Dardha \emph{et al.} \cite{Dardha2013,Dardha2017} combined structural subtyping and boolean types, on one hand, with nominal subtyping, on the other, in Featherweight Java (FJ), by thus exploiting the benefits of both approaches.

However, these benefits were only presented and exemplified at a theoretical level and not exploited practically.
At last, in this work we have implemented SFJ---Semantic Featherweight Java, which features structural subtyping and boolean types as well as nominal subtyping, typical of FJ itself.
The benefits of SFJ, also illustrated in the accompanied video, show how static type checking of boolean types and semantic subtyping gives higher guarantees of program correctness, more flexibility and compactness of program writing.
\keywords{Nominal subtyping \and Structural subtyping  \and Semantic Featherweight Java \and Object-oriented languages \and Boolean types \and Type theory.}
\end{abstract}


\section{Introduction}
There are two approaches to defining subtyping relations: the \emph{syntactic} and the \emph{semantic} approach.
In the latter, one starts by defining a model of the programming language at hand and an interpretation of its types as subsets of such model.
The syntactic subtyping is more mainstream in programming languages design and implementation, and the relation is given by means of a set of formal deductive subtyping rules.
The semantic subtyping is less know and the relation is given by inclusion of sets denoting types. One starts from a formal model of the programming language at hand and defines an interpretation, or semantics, of types as subsets of this model; subtyping naturally is defined as inclusion of these sets, hence the semantic adjective attached to it.
Orthogonally, especially for object-oriented languages, there are two approaches to defining subtyping relation: the \emph{nominal} and the \emph{structural} approach.
The nominal subtyping relation is based on \emph{declarations} by the developer and is \emph{name}-based, hence the adjective nominal: $A$ is a subtype of $B$ if and only if it is declared to be so, that is if the class $A$ extends (or implements) the class (or interface) $B$.
The structural subtyping relation instead is based on the \emph{structure} of a class, its fields and methods: a class $A$ is a subtype of a class $B$ if and only if the fields and methods of $A$ are a superset of the fields and methods of $B$, and their types in $A$ are subtypes of the types in $B$.
At this point it is not surprising that the nominal subtyping aligns well with the syntactic approach and hence is more well-known than the structural subtyping which aligns well with the semantic approach.

Dardha \emph{et al.} \cite{Dardha2013,Dardha2017} define boolean types and semantic subtyping for \emph{Featherweight Java} (FJ) \cite{featherweight}, which is the functional fragment of the Java language.
This approach to defining subtyping naturally allows for structural subtyping in FJ.
On the other hand, nominal subtyping, typical of FJ, can be obtained in the framework exploiting boolean types and semantic subtyping, as shown in the extensive case studies in Dardha \emph{et al.} \cite[\S 8.4]{Dardha2017}.

\begin{example}[The Polygons]
We will use the \emph{Polygons} as our running example, to illustrate the benefits of the approach by Dardha \emph{et al.} \cite{Dardha2013,Dardha2017}, both in the paper and in the tool video.
Consider the set of polygons, such as triangles, rectangles, rumbles given by a class hierarchy.
We want to define a method \emph{diagonal} that takes a polygon and returns the length of its longest diagonal. This method makes sense only if the polygon passed to it has at least four sides, hence triangles are excluded.
In Java this could be implemented in the following ways:
$$
\begin{array}{l}
\synclass Polygon \ \{ \cdots\}
\\
\syndecl{Triangle}{Polygon} {\cdots}
\\
\syndecl{Other\_Polygons}{Polygon} {
\\
	\qquad \mathbf{real}\ diagonal(Other\_Polygons \ p)\ \{\ldots \}
	\\
	\hspace{3.5cm} \ldots
	\\
}
\\
\syndecl{Rectangle}{Other\_Polygons}{\cdots}
\\
\syndecl{Rumble}{Other\_Polygons} {\cdots}
\end{array}
$$
Or by means of an interface:
$$
\begin{array}{l}
public \ \syninterface Diagonal\ \{
	\\
	\qquad \mathbf{real}\ diagonal(Polygon \ p);
	\\
\}
\\
\synclass Polygon \ \{\cdots\}
\\
\syndecl{Triangle}{Polygon} {\cdots}
\\
\synidecl{Rectangle}{Polygon} \synimpl Diagonal \ \{\cdots\}
\\
\synidecl{Rumble}{Polygon} \synimpl Diagonal \ \{\cdots\}
\\
\hspace{4.5cm} \ldots
\end{array}
$$

Now, suppose that our class hierarchy is such that \emph{Polygon} is the parent class and all other geometric figure classes extend \emph{Polygon}, which is exactly how one would naturally define the set of polygons. If we think of the class hierarchy as given and part of legacy code, which cannot be changed, then again the natural way to solve this in Java is by defining the method \emph{diagonal} in the class \emph{Polygon} and using an \textbf{instanceof}, for example inside a \textbf{try-catch} that throws an exception at run time, if the argument passed to the method is a triangle.

The approach proposed by Dardha \emph{et al.} \cite{Dardha2013,Dardha2017} allows for the class hierarchy to be defined in such a natural way without needing to change it, but on the other hand it does not require handling exceptions at run time,  rather just static type checking.
To achieve this, the framework combines boolean types with semantic subtyping: it is enough to define a method \emph{diagonal} that has an argument of type \emph{Polygon} and not \emph{Triangle} thus allowing the type checker to check at compile time the restrictions on types:
$$
\begin{array}{l}
\syndecl{Polygon}{Object} {\cdots}
\\
\syndecl{Triangle}{Polygon} {\cdots}
\\
\syndecl{Rectangle}{Polygon} {\cdots}
\\
\syndecl{Rumble}{Polygon} {\cdots}
\\
\hspace{2.5cm} \ldots
\\
\syndecl{Diagonal}{Object} {
	\\
	\qquad \mathbf{real}\ diagonal(\textit{Polygon} \textbf{ and not }  \textit{Triangle} \ p)\{\ldots\}
	\\
}
\end{array}
$$
We can now call \emph{diagonal} on an argument of type \emph{Polygon}: if the polygon is \textbf{not} a \emph{Triangle}, then the method returns the length of its longest diagonal; otherwise, if the polygon is a triangle, then there will be a type error at compile time.
\end{example}
The combination of boolean types and semantic subtyping gives a more elegant solution, as illustrate by the \emph{Polygons}---of course a toy example used only as a proof of concept of the approach---however, this approach is not yet practical as there are no boolean types or semantic subtyping in Java, hence its benefits unfortunately remained theoretical.

After a few years, finally we can now exploit the benefits of this approach at a practical level: in this paper we present SFJ---Semantic Featherweight Java \autoref{sec:design}, an implementation of Featherweight Java with integrated boolean types and semantic subtyping.
In SFJ the programmer has a larger and more expressive set of types, by using \textbf{and}, \textbf{not}, \textbf{or} boolean connectives. This added expressivity does not however introduce added complexity, but rather the opposite is true as the programmer has an easier, more compact and more elegant way of programming. Moreover, as demonstrated in Dardha \emph{et al.} \cite[\S 8.4]{Dardha2017}, the added expressivity allows for standard programming constructs and features in Java, for e.g., lists, or overloading classes (via multimethods below), to be easily encoded in our framework. Another benefit of semantic subtyping is that it can allow a natural integration of structural and nominal subtyping which the programmer has the option to choose, making SFJ a conservative extension of FJ.

\paragraph{On multimethods}
Since FJ is a core language, some features of the full Java are removed: overloading methods is one of them.
In our framework, leveraging the expressivity of boolean connectives and semantic subtyping, many of these features, and language constructs, e.g., lists, are restored: overloading methods is one of them. We can thus model \emph{multimethods}, \cite{BC97}, which according to the authors is ``\emph{very clean and easy to understand [...] it would be the best solution for a brand new language}".
As an example Dardha \emph{et al.}  \cite{Dardha2013,Dardha2017}, consider the following class declarations:
$$
\begin{array}{ll}
\syndecl{A}{\mathit{Object}} {
&
\qquad
\syndecl{B}{A} {
\\
	%\qquad\quad \ldots
%&
	%\qquad\qquad\quad \ldots
%\\
	\qquad\quad \mathbf{int}\ \mathit{length}\ (\mathbf{string}\ s)\{\ \ldots\ \}\qquad
&
	\qquad\qquad\quad \mathbf{int}\ \mathit{length}\ (\mathbf{int}\ n)\{\ \ldots\ \}
\\
}
&
\qquad }
\end{array}
$$
Method {\it length} has type $\mathbf{string} \rightarrow \mathbf{int}$ in $A$. However, in $B$ it has type $(\mathbf{string} \rightarrow \mathbf{int}) \synwedge (\mathbf{int} \rightarrow \mathbf{int})$,
which can be simplified as $(\mathbf{string} \synvee \mathbf{int}) \rightarrow \mathbf{int}$.

The technical developments behind semantic subtyping and its properties are not easy, however, they are completely transparent to the programmer.
Due to space limit we will remove theoretical details from this submission, as they are not necessary to understand the design and implementation of SFJ, which is the focus of this paper. We refer the reader to the relevant work \cite{Dardha2013,Dardha2017} and we will include the background on semantic subtyping in a possible full paper.


\section{SFJ: Design and Implementation}
\label{sec:design}
The key notion in semantic subtyping is denoting types as sets of values. 
Since we want these types to be able to be finitely representable, we restrict our types to finite trees whose leaves are constants with no cycles. 
For example a recursive type $\alpha = [a : \alpha]$ would be an infinite tree \textbf{new} $C$(\textbf{new} $C$($\cdots{}$)). 
Similarly the types $\alpha = [b: \beta]$, $\beta = [a = \alpha]$ would also be impossible to instantiate.

Therefore, when processing the abstract syntax tree (AST) of a program, we do not allow the type of the class we are defining to be the type of its own field. 
Secondly we mark any classes with only basic types \textit{(bool, int, float ...)} for the types of its fields as \textit{resolved} and otherwise, if it contains a class type, we mark it as \textit{unresolved}. 
After processing the whole AST, we perform the following algorithm to decide whether the type definitions in the program are valid.
\begin{verbatim}
do
    boolean resolutionOccured = false
    for class that is unresolved:
        boolean resolved = true
        for field that contains a class type:
            if class type is not resolved
                resolved = false
        if resolved is true:
            set class to be resolved
            resolutionOccured = true
while resolutionOccured is true

if all classes are not resolved:
    program contains invalid type definition
\end{verbatim}

If the types in the program are finite trees finite trees whose leaves are constants with no cycles, then at each iteration of the algorithm, either all the types are going to be resolved, or we are going to be able to resolve at least one type. 
If we do not resolve at least one type and not all types are resolved, we know we have encountered a cycle in the type definition. 

Given that we now know that all the types in the program are valid, we can create the subtyping relation which will be a map of types to a set of its subtypes. 
For every program, we assume an initial subtyping relation for all of our basic types. 
We would like to highlight that \textit{Int} is not a subtype of \textit{Float} as it cannot represent the whole domain of \textit{Int} accurately and therefore the domain is not fully contained, however this is not the case for \textit{Double} and \textit{Int}. 
Similarly so \textit{Long} is not a subtype of \textit{Double}.
\begin{flalign*}
    Boolean &= \left\{Boolean \right\} &\\
    Double  &= \left\{Double, Float, Int, Short, Byte\right\} &\\
    Float &= \left\{Float, Short, Byte\right\} &\\
    Long &= \left\{Long, Int, Short, Byte\right\} &\\
    Int &= \left\{Int, Short, Byte\right\} &\\
    Short &= \left\{Short, Byte\right\} &\\
    Byte &= \left\{Byte\right\} &
\end{flalign*}

Knowing that all our types are finite trees with leaves as constants and given this initial relation, we can create a subtyping relation for all class types using the following algorithm.

\begin{verbatim}
function generateRelation(classes):
    List<class> untyped = []
    for class in classes:
        if addClass(class) is false:
            untyped.add(class)
    if untyped is not []:
        generateRelation(untyped)

function addClass(class):
    for existing class type in relation:
        if checkSuperSet(class, existingClass) is false:
            return false
        checkSuperSet(existingClass, class)
        add class to its own subtype relation

function checkSuperSet(class, other):
    boolean flag = true
    for field in class:
        if field contains type not in relation:
            return false
        if other does not have field:
            flag = false
        else:
            if other.field.types not fully contains field.types:
                flag = false
    for method in class:
        if method contains type not in relation:
            return false
        if other does not have method:
            flag = false
        else:
            if other.method.types not fully contains method.types:
                flag = false
    if flag == true:
        add class to other subtype relation
\end{verbatim}

Continuing with the Polygons example, the algorithm would generate the following relation, including all base relations we defined before.
\begin{flalign*}
    Polygon &= \left\{Polygon, Triangle, Rectangle, Rumble \right\} &&\\
    Triangle  &= \left\{Triangle\right\}  
    Rectangle = \left\{Rectangle\right\} 
    Diagonal = \left\{Diagonal\right\} 
\end{flalign*}

Given method \textit{diagonal} from the example, we can see that the result of the set operation on its parameter type would be 
\begin{flalign*}
    Polygon \textbf{ and not } Triangle = \left\{Polygon, Rectangle, Rumble \right\} 
\end{flalign*}
Therefore if we try to pass an argument of type $Triangle$ to this method, the type if not fully contained within the computed set, so it does not type check.

The above subtyping algorithm will find all nominal subtypes, as nominal subtypes inherit all fields and methods of their super class, so are always guaranteed to be a superset. 
Similarly, we can check every pair of types if one is a superset of the other, i.e.\ they share common fields and methods, and if so, we know it is a structural subtype of the other. 
For example, the Empty type, $empty = []$, will have all other classes as structural subtypes. 
The above algorithm will without differentiating, find all nominal and structural subtypes as we always consider all other classes in the program to be potential subtype candidates.

The argument against structural subtyping comes up here, as a type $coord = [x:int, y:int, z:int]$ will be structurally similar to a type $colour = [x:int, y:int, z:int]$. 
While they can be used interchangeable in our type system, the meaning of the types are completely different so it means we ignore possible wrong behaviour in our program. 
We however argue that it is no more unsafe than nominal subtyping in Java where an overridden method can be defined to perform the opposite logic to what the super class expects. 
Therefore both methods leave an expectation on the programmer to check what they are doing is correct. 

Furthermore, we have extended FJ with method types, demonstrated below to show another possible implementation of the Polygons example, where we only implement the \textit{diagonal} method on polygons that support it, and not in the Triangle class. 
$$
\syndecl{Diagonal}{Object} {
	\mathbf{int}\ diagonal(\textit{(getDiagonal: void$\rightarrow$int)}  \ p)\{\ldots\}
}
$$

While we do not generate a relation for each method in all classes as this is computationally unnecessary, we can on encountering a method type generate the set of classes which implement this method and combine their subtype relations using the \textit{or} operator. 
We can then use the same set inclusion to see if the argument passed to this function type checks. 

In the implementation of SFJ, we are liberal in the use of fields and method which might not be implemented for all types in the subtyping relation rather than restricting only it to those which we know are shared by all types.
Improper use of this allows for run-time exceptions however it more closely follows the idea of giving the programmer tools to create more expressive programs at the cost of checking program correctness such as with the use of structural subtypes. 


\section{Related Work and Conclusion}
\label{sec:conclusion}
Semantic subtyping approach goes back to more than two decades ago \cite{Aiken,Damm}.
Notable lines of work include:
Hosoya and Pierce \cite{XML1,XML2,XML3} who define XDuce, an XML-oriented language designed specifically to transform XML documents in other XML documents satisfying certain properties.
Castagna \emph{et al.} \cite{gentle,Cas05,FCB08} extend XDuce with first-class functions and arrow types and implement it as $\mathbb{C}$Duce. The starting point of their framework is a higher-order $\lambda-$calculus with pairs and projections.
Castagna \emph{et al.} \cite{Cpi} define $\mathbb{C}\pi$, a variant of the asynchronous $\pi-$calculus \cite{sangiorgi}, where channel types are augmented with boolean connectives.
Ancona and Lagorio~\cite{AL10} define subtyping for infinite types coinductively by using union and object type constructors, where types are interpreted as sets of value of the language.
Bonsangue \emph{et al.}~\cite{BRABR14} study a coalgebraic approach to coinductive types and define a set-theoretic interpretation of coinductive types with union types.
Pearce \cite{Pearce19} defines semantic subtyping for rewriting rules in the Whiley Rewrite Language and for a flow-typing calculus  \cite{Pearce13}.

To conclude, in this paper we presented the design and implementation of SFJ, an extension of Featherweight Java with boolean types and semantic subtyping, which combined allow for both structural and nominal subtyping in FJ as well as restore standard Java constructs for e.g., lists and features for e.g., overloading which were not present in FJ.

%% References
\newpage
\bibliographystyle{splncs04}
\bibliography{paper}

\end{document}
