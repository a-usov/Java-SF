\documentclass[runningheads]{llncs}
%%%%%%%%%%%%%%%%%%%%%%%%
%PACKAGES
%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
%\usepackage{marvosym}
%\usepackage{txfonts}
%\usepackage{multicol}
\usepackage{proof-dashed}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{stmaryrd}

\addto\extrasenglish{%
  \renewcommand{\sectionautorefname}{\S}%
}

\makeatletter
\def\verbatim@font{\linespread{0.75}\normalfont\ttfamily}
\makeatother

% Non standard
%\usepackage{varacca}
\input semmacros

\begin{document}

\title{SFJ: An implementation of Semantic Featherweight Java
%\thanks{Research supported by the UK EPSRC grant EP/K034413/1, ``From Data Types to Session Types: A Basis for Concurrency and Distribution (ABCD)'', and by the EU HORIZON 2020 MSCA RISE project 778233 ``BehAPI: Behavioural Application Program Interfaces''.}
}
\titlerunning{SFJ}

\author{Artem Usov \and Ornela Dardha\orcidID{0000-0001-9927-7875}}
\authorrunning{A. Usov and O. Dardha}

\institute{School of Computing Science, University of Glasgow, United Kingdom \\
    \email{\{artem.usov, ornela.dardha\}@glasgow.ac.uk}}

\maketitle

\begin{abstract}
\emph{Subtyping} is a key notion in programming languages, as it allows more flexibility in coding.
There are two approaches to defining subtyping relations: the \emph{syntactic} and the \emph{semantic} approach.
In the latter, one starts by defining a model of the language and an interpretation of types as subsets of this model.
Subtyping is defined as \emph{set inclusion of types} denoting sets.
An orthogonal issue, typical of object-oriented languages, is the \emph{nominal} vs. \emph{structural} subtyping.
Dardha \emph{et al.} \cite{Dardha2013,Dardha2017} combined structural subtyping and boolean types, on one hand, with nominal subtyping, on the other, in Featherweight Java (FJ), by thus exploiting the benefits of both approaches.

However, these benefits were illustrated only at a theoretical level but not exploited practically.
In this paper, we present SFJ---Semantic Featherweight Java, an implementation of FJ with features structural subtyping and boolean types as well as nominal subtyping.
The benefits of SFJ, also illustrated in the accompanied video, show how static type checking of boolean types and semantic subtyping gives higher guarantees of program correctness, more flexibility and compactness of program writing.
%\keywords{Nominal subtyping \and Structural subtyping  \and Semantic Featherweight Java \and Object-oriented languages \and Boolean types \and Type theory.}
\end{abstract}


\section{Introduction}
There are two approaches to defining subtyping relations: the \emph{syntactic} and the \emph{semantic} approach.
The syntactic subtyping is more mainstream in programming languages and is defined by means of a set of formal deductive subtyping rules.
The semantic subtyping is less know and is defined as inclusion of sets denoting types. Starting from a formal model of the  language, we define an interpretation of types as subsets of this model, typically, subsets of values in the language. Then, subtyping is defined as inclusion of these subsets.

Orthogonally, for object-oriented languages there are two approaches to defining subtyping relations: the \emph{nominal} and the \emph{structural} approach.
The nominal subtyping is based on {declarations} by the developer and is {name}-based: $A$ is a subtype of $B$ if and only if it is declared to be so, that is if the class $A$ extends (or implements) the class (or interface) $B$.
The structural subtyping instead is based on the \emph{structure} of a class, its fields and methods: a class $A$ is a subtype of a class $B$ if and only if the fields and methods of $A$ are a superset of the fields and methods of $B$, and their types in $A$ are subtypes of the types in $B$.
At this point it is not surprising that the nominal subtyping aligns well with the syntactic approach and in fact is more well-known than the structural subtyping which in turn aligns well with the semantic approach.

Dardha \emph{et al.} \cite{Dardha2013,Dardha2017} define semantic subtyping for \emph{Featherweight Java} (FJ) \cite{featherweight} with \emph{boolean types}.
This approach allows the co-existence of nominal and structural subtyping in FJ, bringing in higher guarantees of program correctness, flexibility and compactness in programming.
Unfortunately, these benefits were only presented at a theoretical level and not exploited practically, due to the lack of an implementation of the language and its types and type system.

In this paper, we present SFJ---\emph{Semantic Featherweight Java} \autoref{sec:design}, an implementation of FJ with integrated boolean types and semantic subtyping.
In SFJ the developer has a larger and more expressive set of types, by using boolean connectives \textbf{and}, \textbf{not}, \textbf{or}. On the other hand, this added expressivity does not introduce added complexity, but rather the opposite is true, as the developer has an easier, more compact and more elegant way of programming.
SFJ integrates both structural and nominal subtyping, and the developer can choose which one to use.
Finally, as discussed in Dardha \emph{et al.} \cite[\S 8.4]{Dardha2017}, we can easily encode in SFJ standard programming constructs and features of Java, such as lists, or overloading classes (via multimethods, see below), which are missing in FJ, making SFJ a more complete and closer to Java programming language.

\begin{example}[Polygons]
This will be our running example both in the paper and in the tool video \cite{UD20} to illustrate the benefits of boolean types and semantic subtyping developed by Dardha \emph{et al.} \cite{Dardha2013,Dardha2017} and implemented as SFJ.

Consider the set of polygons, such as triangles, rectangles, rumbles given by a class hierarchy.
We want to define a method \emph{diagonal} that takes a polygon and returns the length of its longest diagonal. This method makes sense only if the polygon passed to it has at least four sides, hence triangles are excluded.
In Java this could be implemented in the following ways:
$$
\begin{array}{l}
\synclass Polygon \ \{ \ldots\}
\\
\syndecl{Triangle}{Polygon} {\ldots}
\\
\syndecl{Other\_Polygons}{Polygon} {
\\
	\qquad \mathbf{real}\ diagonal(Other\_Polygons \ p)\ \{\ldots \}
	\\
	\hspace{3.5cm} \ldots
	\\
}
\\
\syndecl{Rectangle}{Other\_Polygons}{\ldots}
\\
\syndecl{Rumble}{Other\_Polygons} {\ldots}
\end{array}
$$
Or by means of an interface \emph{Diagonal}:
$$
\begin{array}{l}
public \ \syninterface Diagonal\ \{
	\\
	\qquad \mathbf{real}\ diagonal(Polygon \ p);
	\\
\}
\\
\synclass Polygon \ \{\ldots\}
\\
\syndecl{Triangle}{Polygon} {\ldots}
\\
\synidecl{Rectangle}{Polygon} \synimpl Diagonal \ \{\ldots\}
\\
\synidecl{Rumble}{Polygon} \synimpl Diagonal \ \{\ldots\}
\\
\hspace{4.5cm} \ldots
\end{array}
$$

Now, suppose that our class hierarchy is such that \emph{Polygon} is the parent class and all other geometric figure classes extend \emph{Polygon}, which is how one would naturally define the set of polygons.
If we think of the class hierarchy as given and part of legacy code, which cannot be changed, then again a natural way to implement this in Java is by defining the method \emph{diagonal} in the class \emph{Polygon} and using an \textbf{instanceof}, for e.g., inside a \textbf{try-catch} that throws an exception at run time, if the argument passed to the method is a triangle.

We propose a more elegant solution, by combining boolean types and semantic subtyping, where only static typechecking is required and implement this in SFJ \cite{UD20}: it is enough to define a method \emph{diagonal} that has an argument of type \emph{Polygon} \textbf{and not} \emph{Triangle} thus allowing the typechecker to check at compile time the restrictions on types:
$$
\begin{array}{l}
\syndecl{Polygon}{Object} {\ldots}
\\
\syndecl{Triangle}{Polygon} {\ldots}
\\
\syndecl{Rectangle}{Polygon} {\ldots}
\\
\syndecl{Rumble}{Polygon} {\ldots}
\\
\hspace{2.5cm} \ldots
\\
\syndecl{Diagonal}{Object} {
	\\
	\qquad \mathbf{real}\ diagonal(\textit{Polygon} \textbf{ and not }  \textit{Triangle} \ p)\{\ldots\}
	\\
}
\end{array}
$$
We can now call \emph{diagonal} on an argument of type \emph{Polygon}: if the polygon is \textbf{not} a \emph{Triangle}, then the method returns the length of its longest diagonal; otherwise, if the polygon is a triangle, then there will be a type error at compile time.
\end{example}
\emph{On multimethods}
Since FJ is a core language, some features of the full Java are removed: overloading methods is one of them.
In our framework, leveraging the expressivity of boolean connectives and semantic subtyping, many of these features, and language constructs, e.g., lists, are restored: overloading methods is one of them. We can thus model \emph{multimethods}, \cite{BC97}, which according to the authors is ``\emph{very clean and easy to understand [...] it would be the best solution for a brand new language}".
As an example Dardha \emph{et al.}  \cite{Dardha2013,Dardha2017}, consider the following class declarations:
$$
\begin{array}{ll}
\syndecl{A}{\mathit{Object}} {
&
\qquad
\syndecl{B}{A} {
\\
	%\qquad\quad \ldots
%&
	%\qquad\qquad\quad \ldots
%\\
	\qquad\quad \mathbf{int}\ \mathit{length}\ (\mathbf{string}\ s)\{\ \ldots\ \}\qquad
&
	\qquad\qquad\quad \mathbf{int}\ \mathit{length}\ (\mathbf{int}\ n)\{\ \ldots\ \}
\\
}
&
\qquad }
\end{array}
$$
Method {\it length} has type $\mathbf{string} \rightarrow \mathbf{int}$ in $A$. However, in $B$ it has type $(\mathbf{string} \rightarrow \mathbf{int}) \synwedge (\mathbf{int} \rightarrow \mathbf{int})$,
which can be simplified as $(\mathbf{string} \synvee \mathbf{int}) \rightarrow \mathbf{int}$.

The technical developments behind semantic subtyping and its properties are not easy, however, they are completely transparent to the developer.
Due to space limit we will remove theoretical details from this submission, as they are not necessary to understand the design and implementation of SFJ, which is the focus of this paper. We refer the reader to the relevant work \cite{Dardha2013,Dardha2017} and we will include the background on semantic subtyping in a possible full paper.


\section{SFJ: Design and Implementation}
\label{sec:design}
As already discussed in the introduction, the key idea behind semantic subtyping is interpreting types as sets, in particular,  as sets of values of the language at hand. Since we want these types
to be able to be finitely representable, we restrict our types to finite trees whose
leaves are constants with no cycles. For example a recursive type $\alpha = [a : \alpha]$ would
be an infinite tree \textbf{new} $C$(\textbf{new} $C$($\ldots{}$)). Similarly the types $\alpha =
[b: \beta]$, $\beta = [a = \alpha]$ would also be impossible to instantiate.

Therefore, when processing the abstract syntax tree (AST) of a program, we do not allow the type of
the class we are defining to be the type of its own field. Secondly we mark any classes with only
basic types \textit{(bool, int, float ...)} for the types of its fields as \textit{resolved} and otherwise, if it contains a class type, we mark it as \textit{unresolved}. After processing the whole AST, we perform the following algorithm to decide whether the type definitions in the program are valid.
\begin{verbatim}
do
    boolean resolutionOccured = false
    for class that is unresolved:
        boolean resolved = true
        for field that contains a class type:
            if class type is not resolved
                resolved = false
        if resolved is true:
            set class to be resolved
            resolutionOccured = true
while resolutionOccured is true

if all classes are not resolved:
    program contains invalid type definition
\end{verbatim}

If the types in the program are finite trees finite trees whose leaves are constants with no cycles,
then at each iteration of the algorithm, either all the types are going to be resolved, or we are
going to be able to resolve at least one type. If we do not resolve at least one type and not all 
types are resolved, we know we have encountered a cycle in the type definition. 

Given that we now know that all the types in the program are valid, we can create the subtyping
relation which will be a map of types to a set of its subtypes. For every program, we assume an
initial subtyping relation for all of our basic types. We would like to highlight that \textit{Int}
is not a subtype of \textit{Float} as it cannot represent the whole domain of \textit{Int} accurately
and therefore the domain is not fully contained, however this is not the case for \textit{Double} 
and \textit{Int}. Similarly so \textit{Long} is not a subtype of \textit{Double}.
\begin{flalign*}
    Boolean &= \left\{Boolean \right\} &\\
    Double  &= \left\{Double, Float, Int, Short, Byte\right\} &\\
    Float &= \left\{Float, Short, Byte\right\} &\\
    Long &= \left\{Long, Int, Short, Byte\right\} &\\
    Int &= \left\{Int, Short, Byte\right\} &\\
    Short &= \left\{Short, Byte\right\} &\\
    Byte &= \left\{Byte\right\} &
\end{flalign*}

Knowing that all our types are finite trees with leaves as constants and given this initial
relation, we can create a subtyping relation for all class types using the following
algorithm.

\begin{verbatim}
function generateRelation(classes):
    List<class> untyped = []
    for class in classes:
        if addClass(class) is false:
            untyped.add(class)
    if untyped is not []:
        generateRelation(untyped)

function addClass(class):
    for existing class type in relation:
        if checkSuperSet(class, existingClass) is false:
            return false
        checkSuperSet(existingClass, class)
        add class to its own subtype relation

function checkSuperSet(class, other):
    boolean flag = true
    for field in class:
        if field contains type not in relation:
            return false
        if other does not have field:
            flag = false
        else:
            if other.field.types not fully contains field.types:
                flag = false
    for method in class:
        if method contains type not in relation:
            return false
        if other does not have method:
            flag = false
        else:
            if other.method.types not fully contains method.types:
                flag = false
    if flag == true:
        add class to other subtype relation
\end{verbatim}

Continuing with the Polygons example, the algorithm would generate the following relation, including all base relations we defined before.
\begin{flalign*}
    Polygon &= \left\{Polygon, Triangle, Rectangle, Rumble \right\} &&\\
    Triangle  &= \left\{Triangle\right\}  
    Rectangle = \left\{Rectangle\right\} 
    Diagonal = \left\{Diagonal\right\} 
\end{flalign*}

Given method \textit{diagonal} from the example, we can see that the result of the set operation on its parameter type would be 
\begin{flalign*}
    Polygon \textbf{ and not } Triangle = \left\{Polygon, Rectangle, Rumble \right\} 
\end{flalign*}
Therefore if we try to pass an argument of type $Triangle$ to this method, the type
if not fully contained within the computed set, so it does not type check.

The above subtyping algorithm will find all nominal subtypes, as nominal subtypes inherit all fields
and methods of their super class, so are always guaranteed to be a superset. Similarly, we can check
every pair of types if one is a superset of the other, i.e.\ they share common fields and
methods, and if so, we know it is a structural subtype of the other. For example, the Empty type,
$empty = []$, will have all other classes as structural subtypes. The above algorithm will 
without differentiating, find all nominal and structural subtypes as we always consider all other
classes in the program to be potential subtype candidates.

The argument against structural subtyping comes up here, as a type $coord = [x:int, y:int, z:int]$ will be structurally similar to a type $colour = [x:int, y:int, z:int]$. While they can be used 
interchangeable in our type system, the meaning of the types are completely different so it means
we ignore possible wrong behaviour in our program. We however argue that it is no more unsafe than
nominal subtyping in Java where an overridden method can be defined to perform the opposite
logic to what the super class expects. Therefore both methods leave an expectation on the programmer
to check what they are doing is correct. 

Furthermore, we have extended FJ with method types, demonstrated below to show another possible
implementation of the Polygons example, where we only implement the \textit{diagonal} method on 
polygons that support it, and not in the Triangle class. 
$$
\syndecl{Diagonal}{Object} {
	\mathbf{int}\ diagonal(\textit{(getDiagonal: void$\rightarrow$int)}  \ p)\{\ldots\}
}
$$

While we do not generate a relation for each method in all classes as this is computationally 
unnecessary, we can on encountering a method type generate the set of classes which implement this
method and combine their subtype relations using the \textit{or} operator. We can then use the same set inclusion to see if the argument passed to this function type checks. 

In the implementation of SFJ, we are liberal in the use of fields and method which might not be 
implemented for all types in the subtyping relation rather than restricting only it to those which
we know are shared by all types. Improper use of this allows for run-time exceptions however it
more closely follows the idea of giving the programmer tools to create more expressive programs
at the cost of checking program correctness such as with the use of structural subtypes. 


\section{Related Work and Conclusion}
\label{sec:conclusion}
Semantic subtyping approach goes back to more than two decades ago \cite{Aiken,Damm}.
Notable lines of work include:
Hosoya and Pierce \cite{XML1,XML2,XML3} who define XDuce, an XML-oriented language designed specifically to transform XML documents in other XML documents satisfying certain properties.
Castagna \emph{et al.} \cite{gentle,Cas05,FCB08} extend XDuce with first-class functions and arrow types and implement it as $\mathbb{C}$Duce. The starting point of their framework is a higher-order $\lambda-$calculus with pairs and projections.
Castagna \emph{et al.} \cite{Cpi} define $\mathbb{C}\pi$, a variant of the asynchronous $\pi-$calculus \cite{sangiorgi}, where channel types are augmented with boolean connectives.
Ancona and Lagorio~\cite{AL10} define subtyping for infinite types coinductively by using union and object type constructors, where types are interpreted as sets of value of the language.
Bonsangue \emph{et al.}~\cite{BRABR14} study a coalgebraic approach to coinductive types and define a set-theoretic interpretation of coinductive types with union types.
Pearce \cite{Pearce19} defines semantic subtyping for rewriting rules in the Whiley Rewrite Language and for a flow-typing calculus  \cite{Pearce13}.

To conclude, in this paper we presented the design and implementation of SFJ, an extension of Featherweight Java with boolean types and semantic subtyping, which combined allow for both structural and nominal subtyping in FJ as well as restore standard Java constructs for e.g., lists and features for e.g., overloading which were not present in FJ.

%% References
\newpage
\bibliographystyle{splncs04}
\bibliography{paper}

\end{document}
