\documentclass[runningheads]{llncs}
%%%%%%%%%%%%%%%%%%%%%%%%
%PACKAGES
%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[latin1]{inputenc}
\usepackage[english]{babel}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
%\usepackage{marvosym}
%\usepackage{txfonts}
%\usepackage{multicol}
\usepackage{proof-dashed}
\usepackage{graphicx}
\usepackage{listings}


% Non standard
\usepackage{varacca}
\input semmacros
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\begin{document}

\title{SFJ: An implementation of Semantic Featherweight Java}
\titlerunning{SFJ}

\author{Artem Usov \and Ornela Dardha\orcidID{0000-0001-9927-7875}}
\authorrunning{A. Usov and O. Dardha}

\institute{School of Computing Science, University of Glasgow, United Kingdom \\
    \email{\{artem.usov, ornela.dardha\}@@glasgow.ac.uk}}

\maketitle

\begin{abstract}
    The abstract should briefly summarize the contents of the paper in 15--250 words.

    \keywords{nominal and structural subtyping  \and Featherweight Java 
    \and object-oriented languages \and semantic subtyping \and type theory.}
\end{abstract}


\section{Introduction}

A typing system for a programming language is a set of deduction rules that allow 

\begin{equation}
    \tau ::= \alpha \mid \mu
\end{equation}

\section{Semantic Subtyping for Featherweight Java}

\section{SFJ: Design and Implementation}

Since we want our types to represent sets of values, we restrict our types to finite trees whose 
leaves are constants with no cycles. For example a recursive type $\alpha = [a : \alpha]$ would
be an infinite tree \textbf{new} $C$(\textbf{new} $C$($\cdots{}$)). Similarly the types $\alpha = 
[b: \beta]$, $\beta = [a = \alpha]$ would also be impossible to instantiate. 

Therefore, to not allow this, when processing the AST of a program, we do not allow the type of 
the class we are defining to be a field and we mark any classes with only basic types in it's fields
as \textit{resolved} and otherwise if it contains a class type, we mark it as \textit{unresolved}. 
After processing the whole AST, we perform the following algorithm to decide whether the type 
definitions in the program are valid.

\begin{verbatim}
boolean resolutionOccured = false
do 
    for class that is unresolved:
        boolean resolved = true

        for field that contains a class type:
            if class type is not resolved 
                resolved = false
        
        if resolved is true
            set class to be resolved
            resolutionOccured = true
while resolutionOccured is true

if all classes are not resolved
    program contains invalid type definition
\end{verbatim}

Given that we now know that all the types in the program are valid, we can create the subtyping 
relation which will be a map of types to a set of its subtypes. For every program, we assume the 
initial subtyping relation for all of our basic types. We would like to highlight that Int is not
a subtype of Float as it cannot represent the whole domain of Int accurately therefore the domain is 
not fully contained in Float. Similarly so for Double and Long.

\begin{flalign*}
    Boolean &= \left\{Boolean \right\} &\\
    Double  &= \left\{Double, Float, Int, Short, Byte\right\} &\\
    Float &= \left\{Float, Short, Byte\right\} &\\
    Long &= \left\{Long, Int, Short, Byte\right\} &\\
    Int &= \left\{Int, Short, Byte\right\} &\\
    Short &= \left\{Short, Byte\right\} &\\
    Byte &= \left\{Byte\right\} & 
\end{flalign*}

Knowing that all our types are finite trees with leaves as constants and given this initial
relation, we can now confidently create a subtyping relation for all class types using the following
algorithm.

\begin{verbatim}
function generateRelation(classes):
    List<class> untyped = []

    for class in classes:
        if addClass(class) is false:
            untyped.add(class)
    
    if untyped is not []:
        generateRelation(untyped)

function addClass(class):
    for existing class type in relation:
        if tryAddSubtype(class, existingClass) is false:
            return false

        tryAddSubtype(existingClass, class)        

        add class to its own subtype relation

function tryAddSubtype(class, other):
    boolean flag = true

    for field in class:
        if field contains type not in relation:
            return false

        if other does not have field:
            flag = false
        else:
            if other.field.types not fully contains field.types:
                flag = false 


    for method in class:
        if method contains type not in relation:
            return false

        if other does not have method:
            flag = false
        else:
            if other.method.types not fully contains method.types:
                flag = false

    if flag == true:
        add class to other subtype relation
\end{verbatim}

The following bibliography provides
a sample reference list with entries for journal
articles~\cite{Dardha2017}.

\section{Related Work and Conclusion}

%% References
\bibliographystyle{splncs04}
\bibliography{paper}

\end{document}