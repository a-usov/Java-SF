\documentclass[runningheads]{llncs}
%%%%%%%%%%%%%%%%%%%%%%%%
%PACKAGES
%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
%\usepackage{marvosym}
%\usepackage{txfonts}
%\usepackage{multicol}
\usepackage{proof-dashed}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{stmaryrd}

\renewcommand{\theequation}{\arabic{section}.\arabic{equation}}

% Algorithm typesetting package
\usepackage[plain, shortend, linesnumbered]{algorithm2e}
\SetAlFnt{\sffamily \small}
\SetKwRepeat{Do}{do}{while}
\SetKwProg{Fn}{Function}{:}{end}
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}

%% For section renaming in autoref
\addto\extrasenglish{%
  \renewcommand{\sectionautorefname}{\S}%
  \renewcommand{\subsectionautorefname}{\S}%
  \renewcommand{\algorithmautorefname}{Algorithm}%
  %\renewcommand{\exampleautorefname}{Ex.}%
  \renewcommand{\equationautorefname}{Mapping}%
}

% Non standard
%\usepackage{varacca}
\input{semmacros}

\begin{document}

\title{SFJ: An implementation of Semantic Featherweight Java
    \thanks{Supported by the UK EPSRC grant EP/K034413/1, ``From Data Types to Session Types: A Basis for Concurrency and Distribution'' (ABCD), and by the EU HORIZON 2020 MSCA RISE project 778233
    ``Behavioural Application Program Interfaces'' (BehAPI).}
}
\titlerunning{SFJ}

\author{Artem Usov \and Ornela Dardha\orcidID{0000-0001-9927-7875}}
\authorrunning{A. Usov and O. Dardha}

\institute{School of Computing Science, University of Glasgow, Glasgow, United Kingdom \\
\email{2296905U@student.gla.ac.uk, ornela.dardha@glasgow.ac.uk}}

\maketitle

\begin{abstract}
    There are two approaches to defining subtyping relations: the \emph{syntactic} and the \emph{semantic} approach.
    In semantic subtyping, one defines a model of the language and an interpretation of types as subsets of this model.
    Subtyping is defined as inclusion of subsets denoting types.

    An orthogonal subtyping question, typical of object-oriented languages, is the \emph{nominal} versus the \emph{structural} subtyping.
    Dardha \emph{et al.} \cite{Dardha2013,Dardha2017} defined boolean types and semantic subtyping for Featherweight Java (FJ) and integrated both nominal and structural subtyping, thus exploiting the benefits of both approaches.
    However, these benefits were illustrated only at a theoretical level, but not exploited practically.

    We present SFJ---Semantic Featherweight Java, an implementation of FJ which features boolean types, semantic subtyping and integrates nominal as well as structural subtyping.
    The benefits of SFJ, illustrated in the paper and the accompanying video (with audio/subtitles) \cite{UD20}, show how static type-checking of boolean types and semantic subtyping gives higher guarantees of program correctness, more flexibility and compactness of program writing.
    \keywords{Nominal subtyping \and Structural subtyping  \and Semantic Featherweight Java \and Object-oriented languages \and Boolean types \and Type theory.}
\end{abstract}


\section{Introduction}
\label{sec:intro}
There are two approaches to defining subtyping relations: the \emph{syntactic} and the \emph{semantic} approach.
Syntactic subtyping \cite{Liskov1994} is more mainstream in programming languages and is defined by means of a set of formal deductive subtyping rules.
Semantic subtyping \cite{Castagna2005,Cas05,Frisch2008} is more recent and less known:  one defines a formal model of the language and an interpretation of types as subsets of this model.
Then, subtyping is defined as set inclusion of subsets denoting types.

Orthogonally, for object-oriented languages there are two approaches to defining subtyping relations: the \emph{nominal} and the \emph{structural} approach \cite{Integrating,Useful}.
Nominal subtyping is based on {declarations} by the developer and is \emph{name}-based: ``$A$ is a subtype of $B$ if and only if it is declared to be so, that is if the class $A$ extends (or implements) the class (or interface) $B$''.
Structural subtyping instead is based on the \emph{structure} of a class, its fields and methods: ``a class $A$ is a subtype of a class $B$ if and only if the fields and methods of $A$ are a superset of the fields and methods of $B$, and their types in $A$ are subtypes of the types in $B$''.
For example, the set of inhabitants of a class \emph{Student} is smaller than the set of inhabitants of a class \emph{Person}, as each Student is a Person, but not the other way around.
However, the set of fields and methods of \emph{Student} is a superset of that of \emph{Person}.
Hence, \emph{Student} is a structural subtype of \emph{Person}, even if it is not declared so.


Dardha \emph{et al.} \cite{Dardha2013,Dardha2017} define boolean types---based on set-theoretic operations such as \textbf{and}, \textbf{not}, \textbf{or}---and semantic subtyping for \emph{Featherweight Java} (FJ) \cite{featherweight}.
This approach allows for the integration of both nominal and structural subtyping in FJ, bringing in higher guarantees of program correctness, flexibility and compactness in program writing.
Unfortunately, these benefits were only presented at a theoretical level and not exploited practically, due to the lack of an implementation of the language, its types and type system.

In this paper, we present SFJ---\emph{Semantic Featherweight Java} \autoref{sec:design}, an implementation of FJ with boolean types and semantic subtyping.
In SFJ the developer has a larger and more expressive set of types, by using boolean connectives \textbf{and}, \textbf{not}, \textbf{or}, with the expected set-theoretic interpretation.
On the other hand, this added expressivity does not add complexity.
Rather the opposite is true, as the developer has an easier, more compact and elegant way of programming.
SFJ integrates both structural and nominal subtyping, and the developer can choose which one to use.
Finally, as discussed in Dardha \emph{et al.} \cite[\S 8.4]{Dardha2017}, thanks to semantic subtyping, we can easily encode in SFJ standard programming constructs and features of the full Java language, such as lists, or overloading classes via multimethods \cite{BC97}, which are missing in FJ, thus making SFJ a more complete language closer to Java.

\begin{example}[Polygons]
    \label{polygons}
    This will be our running example both in the paper and in the tool video \cite{UD20} to illustrate the benefits of boolean types and semantic subtyping developed by Dardha \emph{et al.} \cite{Dardha2013,Dardha2017} and implemented as SFJ.

    Consider the set of polygons, such as triangles, squares and rhombuses given by a class hierarchy.
    We want to define a method \emph{diagonal} that takes a polygon and returns the length of its longest diagonal.
    This method makes sense only if the polygon passed to it has at least four sides, hence triangles are excluded.
    In Java this could be implemented in the following ways:
    \begin{equation*}
        \begin{array}{l}
            \synclass Polygon \ \{ \ldots\}
            \\
            \syndecl{Triangle}{Polygon} {\ldots}
            \\
            \syndecl{Other\_Polygons}{Polygon} {
                \\
                \qquad \mathbf{double}\ diagonal(Other\_Polygons \ shape)\ \{\ldots \}
                \\
                \hspace{3.5cm} \ldots
                \\
            }
            \\
            \syndecl{Square}{Other\_Polygons}{\ldots}
            \\
            \syndecl{Rhombus}{Other\_Polygons} {\ldots}
        \end{array}
    \end{equation*}
    Or by means of an interface \emph{Diagonal}:
    \begin{equation*}
        \begin{array}{l}
            public \ \syninterface Diagonal\ \{
            \\
            \qquad \mathbf{double}\ diagonal(Polygon \ shape);
            \\
            \}
            \\
            \synclass Polygon \ \{\ldots\}
            \\
            \syndecl{Triangle}{Polygon} {\ldots}
            \\
            \synidecl{Square}{Polygon} \synimpl Diagonal \ \{\ldots\}
            \\
            \synidecl{Rhombus}{Polygon} \synimpl Diagonal \ \{\ldots\}
            \\
            \hspace{2.5cm} // \text{ other polygons } \ldots
        \end{array}
    \end{equation*}
    Now, suppose our class hierarchy is such that \emph{Polygon} is the parent class and all other geometric figures extend \emph{Polygon}, which is how one would naturally define the set of polygons.
    Suppose the class hierarchy is given and is part of legacy code, which cannot be changed.
    Then again, a natural way to implement this in Java is by defining the method \emph{diagonal} in the class \emph{Polygon} and using an \textbf{instanceof}, for example, inside a \textbf{try-catch} construct.
    Then, an exception would be thrown at runtime, if the argument passed to the method is a triangle.

    We propose a more elegant solution, by combining boolean types and semantic subtyping, where only static type-checking is required and we implement this in SFJ \cite{UD20}: it is enough to define a method \emph{diagonal} that has an argument of type \emph{Polygon} \textbf{and not} \emph{Triangle}, thus allowing the type-checker to check at compile time the restrictions on types:
    \begin{equation*}
        \begin{array}{l}
            \synclass Polygon \ \{\ldots\}
            \\
            \syndecl{Triangle}{Polygon} {\ldots}
            \\
            \syndecl{Square}{Polygon} {\ldots}
            \\
            \syndecl{Rhombus}{Polygon} {\ldots}
            \\
            \hspace{2.5cm} \ldots
            \\
            \synclass Diagonal \ \{
            \\
            %\qquad Diagonal ( )\   \{\ super();\ \}
            \hspace{2.5cm} \ldots \\
            \qquad \mathbf{double}\ diagonal((\textit{Polygon} \textbf{ and not }  \textit{Triangle}) \ shape)\{\ldots\}
            \\
            \}
        \end{array}
    \end{equation*}
    We can now call \emph{diagonal} on an argument of type \emph{Polygon}: if the polygon is \textbf{not} a \emph{Triangle}, then the method computes and returns the length of its longest diagonal; otherwise, there will be a type error at compile time.
\end{example}


%The technical developments behind semantic subtyping and its properties are complex, however, they are completely transparent to the developer.
%Due to space limit we will remove most theoretical details from this submission, as they are not necessary to understand the design and implementation of SFJ, which is the focus of this paper. We refer the reader to the relevant work \cite{Dardha2013,Dardha2017} and we will include a more complete background on semantic subtyping in a possible full paper.

\paragraph{Structure of the paper:}
In \autoref{sec:background} we present the types and terms of the SFJ language.
In \autoref{sec:design} we present the design and implementation of SFJ; we discuss our two main algorithms, \autoref{alg:types} in \autoref{sec:valid} which checks the validity of type definitions, and \autoref{alg:subtyping} in \autoref{sec:subtypingAlgo} which generates the semantic subtyping relation. Further, we discuss typing in SFJ in \autoref{sec:typing}; nominal vs. structural subtyping in \autoref{sec:nominal}; and method types in \autoref{sec:methods}.
We discuss future work, related work and conclude the paper in \autoref{sec:conclusion}.

\input{background.tex}

\section{The SFJ Language}
\label{sec:design}
\subsection{On Valid Type Definitions}
\label{sec:valid}
Since we want to use types $\tau$ in practice in SFJ, we restrict them to \emph{finite trees} whose leaves are basic types $\btypes$ \autoref{sec:terms} with no cycles.
For example, a recursive type $\alpha = [a : \alpha]$ denotes an infinite program tree \textbf{new} $C$(\textbf{new} $C$($\cdots{}$)), hence we rule it out as it is not inhabitable.
Similarly, the types $\alpha = [b: \beta]$, $\beta = [a = \alpha]$ create a cycle and thus would not be inhabitable.
Notice that these types can be defined and inhabited in Java by assigning \emph{null} to all fields in a class, however they are not useful in practice.

SFJ is implemented using ANTLR \cite{parr2013}.
We start by defining the grammar of the language in Extended Backus-Naur Form (EBNF), following \autoref{sec:types} and by running ANTLR, we can automatically generate a parser for SFJ and extend it in order to implement the required checks for our types and type system.
Running the parser on an SFJ program returns an abstract syntax tree (AST) of that program.

When visiting the AST, we check if the program is well-formed, following the intuition at the end of \autoref{sec:background}.
We mark any classes containing fields typed with only basic types as \emph{resolved} otherwise, as \emph{unresolved}.
Using this information, \autoref{alg:types} checks if the type definitions in a program are valid, namely, if they are finite trees whose leaves are basic types with no cycles.
%
At each iteration of the algorithm we can resolve at least one type, until all the types in the SFJ program are resolved, and return $True$.
However, if there is at least one type unresolved, meaning there is a cycle in the type definition, we return $False$.

\begin{algorithm}[t]
    \SetAlgoLined
    \caption{Validity Check for Type Definitions}
    \label{alg:types}

    \DontPrintSemicolon
    \Input{$classes$, the set of classes marked $resolved$ if their fields contain only basic types, $unresolved$ otherwise.}
    \Output{$True$ if all classes are valid type definitions, $False$ otherwise.}
    \BlankLine
    \Begin{
        \Do{$resolutionOccured = True$}{ %\tcc {comment}
            $resolutionOccured \longleftarrow False$ \;
            \For{class that is unresolved in classes}{
                $resolved \longleftarrow True$ \;
                \For{field in class that contains a class type}{
                    \If{type of field is unresolved}{
                        $resolved \longleftarrow False$
                    }

                }
                \;
                \If{$resolved = True$}{
                    $class \longleftarrow resolved$ \;
                    $resolutionOccured \longleftarrow True$ \;
                }
            }
        }
        \;
        \uIf{not all classes are resolved}{
            \KwRet $False$
        }
        \Else{
            \KwRet $True$
        }
    }
\end{algorithm}

\subsection{Building Semantic Subtyping for SFJ}
\label{sec:subtypingAlgo}
If \autoref{alg:types} returns $True$, meaning all type definitions in a program are valid, we can then build the semantic subtyping.
Leveraging the interpretation of types as sets of values to define semantic subtyping for FJ \cite{Dardha2013,Dardha2017}, in SFJ we keep track of the semantic subtyping relation by defining a map from a type to the set of its subtypes, satisfying the property that the set of values of a subtype is included in the set of values of the type.
We start with basic types and let $Universe$ be a supertype of all types.
The full mapping for basic types is defined in \autoref{eq:initialSubtype}.
\begin{equation}
    \label{eq:initialSubtype}
    \begin{array}{llllll}
        & Double   & = \left\{Double, Float, Int, Short, Byte\right\} &  & Float & = \left\{Float, Short, Byte\right\} \\
        & Long     & =    \left\{Long, Int, Short, Byte\right\}       &  & Int   & = \left\{Int, Short, Byte\right\}   \\
        & Short    & =    \left\{Short, Byte\right\}                  &  & Byte  & = \left\{Byte\right\}               \\
        & Boolean  & =    \left\{Boolean\right\}                      &  & Void  & = \left\{Void\right\}               \\
        & Universe & = \{Double, Float, Long, Int,                                                                     \\
        &          & \quad Short, Byte, Boolean, Void\}
   \end{array}
\end{equation}
Note that \emph{Int} is not a subtype of \emph{Float} as a 32-bit \emph{float} cannot represent the whole set of 32-bit \emph{integer} values accurately and therefore \emph{Int} is not fully set-contained in \emph{Float}, however this is not the case for \emph{Int} and \emph{Double}.
Similarly, \emph{Long} is not a subtype of \emph{Double}.

\autoref{alg:subtyping} builds the semantic subtyping relation for all class types of an SFJ program by calling the function \textit{generateRelation}.
Given that classes are valid type definitions by \autoref{alg:types}, we are guaranteed that \autoref{alg:subtyping} will terminate.
The semantic subtyping generated by \autoref{alg:subtyping} is a preorder: it is reflexive and transitive. This is also illustrated by \autoref{eq:initialSubtype}.

Some comments on \autoref{alg:subtyping} follow.
In function $generateRelation$ we iterate over the set of classes in an SFJ program.
If the class currently being processed contains types in its fields or methods not present in the subtyping relation (lines 5, 30, 42), then we add the current class to the list of \emph{unprocessed} classes (line 6) so we can process its fields and methods first and the class itself later after having all required type information.
The set of unprocessed classes will then be inspected again in a recursive call (line 10).
The next two functions of the algorithm, \emph{addClass} and \emph{checkSuperSet}, check subtyping for the current $class$ being processed and update $relation$, which is a mapping from a type to its subtypes and originally only consists of entries from \autoref{eq:initialSubtype}.
In function $addClass(class)$ we check if the type $class$ is a subtype of an existing type in $relation$ (lines 15-18), as well as the opposite, meaning if $class$ is a supertype of an existing type in $relation$ (line 19).
In order to do so $checkSuperSet$ checks all fields (lines 28-39) and all methods (lines 40-51) in $class$ and compares them with an \emph{existingClass} in $relation$.
If a subtyping relation is established, then it is added to $relation$ (line 53).
Finally, upon returning from $checkSuperSet$, we also add $class$ to its own relation (line 21) to satisfy reflexivity and to $Universe$ (line 22), which is a supertype of all types.

\begin{algorithm}
    \caption{Semantic Subtyping for SFJ Classes}
    \label{alg:subtyping}

    \DontPrintSemicolon
    \Input{$classes$, the set of classes in an SFJ program for which we have not yet defined the subtyping relation.\;
    $relation$, the mapping of types to the set of subtypes, initially being Mapping \ref{eq:initialSubtype}. \;
    }
    \Begin{
        \Fn{generateRelation(classes: List<Class>)}{
            $unprocessed: List<Class>\ \longleftarrow []$

            \For{class in classes}{
                \If{addClass(class) = $False$}{
                    $unprocessed.add(class)$
                }
            }
            \If{$untyped \neq []$}{
                $generateRelation(unprocessed)$
            }
        }
        \;
        \Fn{addClass(class: Class) $\rightarrow$ boolean}{
            \For{existing class type in relation}{
                \If{checkSuperSet(class, existingClass) = False}{
                    \KwRet $False$\;
                }
                $checkSuperSet(existingClass, class)$\;
            }
            $relation[class].add(class)$ \;
            $relation[Universe].add(class)$ \;
            \KwRet $True$ \;
        }
        \;
        \Fn{checkSuperSet(class: Class, other: Class) $\rightarrow$ boolean}{
            $flag \longleftarrow True$ \;
            \For{field in class}{
                \If{field contains type not in relation}{
                    \KwRet $False$
                }
                \uIf{other does not contain field}{
                    $flag \longleftarrow False$
                }
                \Else{
                    \If{other.field.types does not fully contain field.types}{
                        $flag \longleftarrow False$
                    }
                }
            }

            \For{method in class}{
                \If{method contains type not in relation}{
                    \KwRet $False$
                }
                \uIf{other does not contain method}{
                    $flag \longleftarrow False$
                }
                \Else{
                    \If{other.method.types does not fully contain method.types}{
                        $flag \longleftarrow False$
                    }
                }
            }

            \If{$flag = True$}{
                $relation[other].add$
            }
        }
    }
\end{algorithm}

It is worth noticing that the subtyping algorithm finds all nominal and structural subtypes of a given type. This is due to the fact that all pairs of types are inspected.
Recall from \autoref{sec:intro} that nominal subtyping is name-based and given by the class hierarchy defined by the programmer, whether structural subtyping is structure-based and given by the set-inclusion of fields and methods. In particular, it is contra-variant with respect to this set-inclusion.
\autoref{alg:subtyping} finds all structural subtypes of a given class because it checks that its fields and methods are a superset of existing types in $relation$. For example, all classes are structural subtypes of type $empty = []$.
On the other hand, it also finds all nominal subtypes because a class inherits all fields and methods of its superclass and as such its fields and methods are a superset of its superclass.
This means that checking for structural subtyping is enough because nominal subtyping will be captured due to inheritance of fields and methods.

Finally, a note on complexity.
The complexity of \autoref{alg:types} is $\mathcal{O}(n)$, and the complexity of \autoref{alg:subtyping} is $\mathcal{O}(n^{2})$, with $n$ being the size of the input.
The reason for a quadratic complexity of \autoref{alg:subtyping} is due to the symmetric check of structural subtyping between a $class$ and an $existingClass$ in $relation$.
Notice that if we were to only work with nominal subtyping, then we only require traversing the class hierarchy once,  which gives an $\mathcal{O}(n)$ complexity.

\subsection{Type System for SFJ}
\label{sec:typing}

The type system for the SFJ language, given in \autoref{sec:terms}, is based on the type system by Dardha \emph{et al.} \cite{Dardha2013,Dardha2017} where the formal typing rules and soundness properties are detailed. As these formal developments are beyond the scope of this paper, we discuss typing for SFJ only informally.

A program $(\tilde L,e)$ is well typed if both $\tilde{L}$ and $e$ are well typed.
Class declaration $L$ and method declaration $M$ are well typed if all their components are well typed.
Let us move onto expressions $E$.
Field access $e.a$, method call $e.m(e)$ and object creation $\synnew C(\wt{e})$ are typed in the same way as in Java: we inspect the type of the field and the type of the method and its arguments to determine the type of the field access and method call, respectively. The type of an object creation is determined by the type of its class.
Regarding constants, in order to respect the set-theoretic interpretation of types as sets of values, we type constants with the most restrictive type, i.e., the type representing the smallest set of values containing the value itself.
For example, the type system would assign to the value $42$ the type \textbf{byte}, which is the smallest in the sequence \textbf{byte}, \textbf{short}, \textbf{int} (see \autoref{eq:initialSubtype} for details).

% Let us move onto constants, where we can also illustrate the boolean connectives. 
% Typing constants in Java uses type casting where the type of a constant changes to be adapted to the context it is being used in.
% %For example, a method $\textbf{long}\ getNum()\{return\ 42;\}$ casts $42$ to \textbf{long}.
% %Instead, in variable type inference $\textbf{var}\ x = 42$, the compiler treats $42$ as having type \textbf{int}, as this is the most efficient type for hardware operations.

% Since in our framework types represent sets of values and the boolean connectives \textbf{and}, \textbf{not}, \textbf{or} are interpreted in a set-theoretic way, typing constants changes from Java as follows.
% Consider the boolean type \textbf{int and} (\textbf{not byte}), this type is interpreted as the set of values $-2^31$ to $2^31 - 1$ removing the values $-128$ to $127$.
% In SFJ, if we were to type $42$ as \textbf{int}, this would also mean that $42$ can be typed by \textbf{int and} (\textbf{not byte}), however, the value itself would not be in the set of values of the type, thus breaking our semantic type system.
% Therefore, our design choice is to type constants with the most restrictive type, i.e., the type representing the smallest set of values containing the value itself.
% With this typing rule, the value $42$ has type \textbf{byte}, and as a consequence it cannot have type \textbf{int and} (\textbf{not byte}).

Finally, the subtyping relation generated by \autoref{alg:subtyping} is used in the type system for the SFJ language via a subsumption typing rule:
 $$
 \frac{\Gamma\vdash e:\alpha_1 \qquad \alpha_1 \leq \alpha_2}{\Gamma \vdash e:\alpha_2}
 $$
We read this typing rule as follows:
if an expression $e$ is of type $\alpha_1$ under a typing context $\Gamma$ (details of a typing context are irrelevant here) and type $\alpha$ is a subtype $\leq$ of $\alpha_2$, then expression $e$ can be typed with $\alpha_2$.


\subsection{Polygons: Continued}

Let us illustrate the semantic subtyping algorithm on our \emph{Polygons} given in \autoref{polygons}.
\autoref{alg:subtyping} generates the subtyping relation given in \autoref{eq:sugtypePolygons}, together with the subtyping relation for basic types, omitted here and defined in \autoref{eq:initialSubtype}. Notice that the mapping for $Universe$ is extended with the new types for polygons.
\begin{equation}
    \label{eq:sugtypePolygons}
    \begin{array}{llllll}
         & Polygon  & = \left\{Polygon, Triangle, Square, Rhombus \right\} &  & Triangle & = \left\{Triangle\right\}           \\
         & Square   & = \left\{Square\right\}                              &  & Rhombus  & = \left\{Rhombus\right\}            \\
         & Universe & = \{Double, Float, Long, Int, Short, Byte                                                              &  & Diagonal & = \left\{Diagonal\right\}          \\
         &          & \quad Boolean, Void, Polygon, Square                                                                     \\
         &          & \quad Square, Rhombus, Diagonal\}
    \end{array}
\end{equation}
Recall the method \emph{diagonal} in class \emph{Diagonal}, with signature
$$
\mathbf{double}\ diagonal((\textit{Polygon} \textbf{ and not }  \textit{Triangle}) \ shape)
$$
The result of the set operation on its parameter type gives the following set of polygons:
$$
Polygon \textbf{ and not } Triangle = \left\{Polygon, Square, Rhombus \right\}
$$
In order to define the \textbf{not} $Triangle$ type we need the $Universe$ type so that we can define it as $Universe\ \mathbf{\setminus}\ Triangle$. Then, the \textbf{and} connective is the intersection of sets of $Polygon$ with \textbf{not} $Triangle$.

If we write in our SFJ program the following expression:
$$
    (\textbf{new}\ Diagonal()).diagonal(\textbf{new}\ Square())
$$
the argument \textbf{new} $Square()$ of the $diagonal$ method is of type $Square$, by the type system in \autoref{sec:typing} and $Square$ is contained in the set of the parameter type of the method, so this expression will successfully type-checks.

However, if we write the following SFJ expression:
$$
    (\textbf{new}\ Diagonal()).diagonal(\textbf{new}\ Triangle())
$$
Type $Triangle$ is not contained in $\left\{Polygon, Square, Rhombus \right\}$, therefore this expression will not type-check and will return a type error at compile time.

This is further illustrated in the accompanying video of this paper \cite{UD20}.

\subsection{Nominal vs. Structural Subtyping}
\label{sec:nominal}
In this section we will comment on pros and cons of nominal vs. structural subtyping.

Structural subtyping allows for more flexibility in defining this relation and the user does not need to explicitly definite it, as would do with nominal subtyping.
However, for this flexibility we might need to pay in meaning.
For example, consider the following two structurally equivalent classes, hence record types
$coordinate = [x:int, y:int, z:int]$ and $colour = [x:int, y:int, z:int]$.
While they can be used interchangeably in a type system using structural subtyping, their ``meaning'' is different and we might want to prohibit it, because intuitively speaking we do not want to use a $colour$ where a $coordinate$ is expected.

On the other hand, while nominal subtyping can avoid the above problem, it can introduce others and in particular, a developer can define an overridden method to perform the opposite logic to what the super class is expecting, as illustrated by the following classes in Java:
\begin{equation*}
    \begin{array}{ll}
        \syndecl{A}{\mathit{Object}} {
         &
            \qquad
            \syndecl{B}{A} {
                \\
               \qquad \qquad\ldots \qquad
         &
                \qquad\qquad\qquad \ldots
                \\
                \quad \textbf{int}\ n;\qquad
         &
                \qquad\quad \textbf{int}\ length()\{\ \synret{-n};\ \}
                \\
                \quad \textbf{int}\ length()\{\ \synret{n};\ \}\qquad
         &
                \qquad}
                \\   }
    \end{array}
\end{equation*}
Both approaches have their pros and cons, and they leave an expectation on the developer to use the logic behind subtyping correctly when writing code. Hence, the integration of both approaches in SFJ makes it possible to  overcome these drawbacks, as one can choose on which subtyping to focus for a given task.

% Dardha \emph{et al.}\cite{Dardha2017} suggest a possible extension to the language by including a $nominal$ keyword that can be used in the class signature to indicate that this class should only be considered by the nominal component of the type system.
% This would allow us finer control over the type system and eliminate the previously mentioned problems.
% However, being optional, we argue this would create more bugs than problems it would solve, due to easily forgetting the keyword.
% For example with destructors in C++ classes,leaving out the virtual keyword of the parent class destructor in certain situations can lead to memory leaks.
% Instead a \emph{structural} keyword could be introduced as an extension to the language which specifies that this class is allowed to have structural subtypes.
% A class with this keyword is not added to the subtyping relation of other structurally similar classes which are not marked \emph{structural} as this would weaken the invariant conditions of that class.


\subsection{Methods in SFJ}
\label{sec:methods}
\paragraph{On multimethods}
Since FJ is a core language, some features of the full Java are removed, such as overloading methods.
In our framework, by leveraging the expressivity of boolean connectives and semantic subtyping, we are able to restore overloading, among other features \cite[\S 8.4]{Dardha2017}.
We can thus model \emph{multimethods}, \cite{BC97}, which according to the authors is ``\emph{very clean and easy to understand [...] it would be the best solution for a brand new language}".
As an example, taken from Dardha \emph{et al.}  \cite{Dardha2013,Dardha2017}, consider the following class declarations:
$$
\begin{array}{ll}
\syndecl{A}{\mathit{Object}} {
&
\qquad
\syndecl{B}{A} {
\\
	%\qquad\quad \ldots
%&
	%\qquad\qquad\quad \ldots
%\\
	\qquad\quad \mathbf{int}\ \mathit{length}\ (\mathbf{string}\ s)\{\ \ldots\ \}\qquad
&
	\qquad\qquad\quad \mathbf{int}\ \mathit{length}\ (\mathbf{int}\ n)\{\ \ldots\ \}
\\
}
&
\qquad }
\end{array}
$$
Method {\it length} has type $\mathbf{string} \rightarrow \mathbf{int}$ in class $A$.
However, because class $B$ extends class $A$,  {\it length} has type $(\mathbf{string} \rightarrow \mathbf{int})\ \synwedge\ (\mathbf{int} \rightarrow \mathbf{int})$ in class $B$,
which can be simplified to $(\mathbf{string}\ \synvee\ \mathbf{int}) \rightarrow \mathbf{int}$.

\paragraph{Method types}
Let us illustrate the method types given in \autoref{sec:types} via an alternative implementation of the class $Diagonal$ at the end of \autoref{polygons}.
$$
\begin{array}{l}
    \synclass Diagonal \ \{
    \\
    \qquad\qquad\qquad \ldots \\
    \qquad \textbf{double}\ diagonal((diagonal: \textbf{void} \rightarrow \textbf{double})\ shape)\\
    \hfill
    \{\ \synret\ shape.diagonal();\ \}
    \\
    \}
\end{array}
$$
We define the type of the (outside) $diagonal$ method as accepting any type and its subtypes implementing the (inside) \emph{diagonal} method with type signature \textbf{void} to \textbf{double}.

In order to type check an argument passed to the (outside) $diagonal$ method, at compile time we build a collection of types $\{type_{1},\ type_{2},\ldots\}$ which are class types where the (inside) $diagonal$ method is defined.
As such, we iterate over the list of \emph{classes} in an SFJ program (as we did in \autoref{alg:subtyping})) to check for the required method.
The resulting collection of types is the union of all classes where $diagonal$ is defined together with their subtypes $([\![type_{1}]\!] \cup [\![type_{2}]\!] \cup \ldots)$, where each $[\![type_{i}]\!]$ denotes a mapping of $type_i$ to the set of its subtypes, similar to \autoref{eq:sugtypePolygons}.

However, calculating this collection of types for each method of every class would be computationally inefficient and most importantly unnecessary as only few methods would in turn be used as method types.
Therefore we only compute them on demand during type-checking when we come across such a type.

We can therefore use method types to statically include or exclude a portion of our class hierarchy.
However, unlike the use of interfaces, as in one of the proposed Java approaches in \autoref{polygons}, the values that can be accepted by a method type do not have to be related to each other in any way in the class hierarchy.
This indeed is useful if we are dealing with legacy code as we can still accept all classes where \emph{diagonal} is defined, without having to go back and add interface implementations.

%In the implementation of SFJ, we are liberal in the use of fields and method which might not be implemented for all types in the subtyping relation rather than restricting only it to those which we know are shared by all types.
%Improper use of this allows for run-time exceptions however it more closely follows the idea of giving the programmer tools to create more expressive programs at the cost of checking program correctness such as with the use of structural subtypes.
\section{Conclusion, Related Work and Future Work}
\label{sec:conclusion}

Semantic subtyping approach goes back to more than two decades ago \cite{Aiken,Damm}.
Notable lines of work include:
Hosoya and Pierce \cite{XML1,XML2,XML3} who define XDuce, an XML-oriented language designed specifically to transform XML documents in other XML documents satisfying certain properties.
Castagna \emph{et al.} \cite{Castagna2005,Cas05,FCB08} extend XDuce with first-class functions and arrow types and implement it as $\mathbb{C}$Duce. The starting point of their framework is a higher-order $\lambda-$calculus with pairs and projections.
Muehlboeck and Tate \cite{Muehlboeck2018} define a syntactic framework with boolean connectives which has been implemented in the Ceylon programming language \cite{Ceylon2016}.
Castagna \emph{et al.} \cite{Cpi} define $\mathbb{C}\pi$, a variant of the asynchronous $\pi-$calculus \cite{sangiorgi}, where channel types are augmented with boolean connectives.
Ancona and Lagorio~\cite{AL10} define subtyping for infinite types coinductively by using union and object type constructors, where types are interpreted as sets of value of the language.
Bonsangue \emph{et al.}~\cite{BRABR14} study a coalgebraic approach to coinductive types and define a set-theoretic interpretation of coinductive types with union types.
Pearce \cite{Pearce19} defines semantic subtyping for rewriting rules in the Whiley Rewrite Language and for a flow-typing calculus  \cite{Pearce13}.

To conclude, in this paper we presented the design and implementation of SFJ, an extension of Featherweight Java with boolean types and semantic subtyping, which allow for both structural and nominal subtyping in FJ as well as restore standard Java constructs for example, lists and features for example, overloading which were not present in FJ, making SFJ a more complete language.

%% References
\newpage
\bibliographystyle{splncs04}
\bibliography{paper}
\end{document}
