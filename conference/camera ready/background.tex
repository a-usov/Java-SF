\section{Background}
\label{sec:background}
The technical developments behind semantic subtyping and its properties are complex, however, they are completely transparent to the programmer. The framework is detailed and proved correct in the relevant work by Dardha \emph{et al.} \cite{Dardha2013,Dardha2017}, and SFJ builds on that framework.

In this section we will briefly detail the types and terms of SFJ.

\subsection{Types}
\label{sec:types}
The syntax of types $\tau$ is defined by the following grammar:
$$
\begin{array}{llll}
\tau & ::= & \alpha \ |\ \mu
& \mbox{{\em Types}}
\\
\alpha & ::=  & \zero \ |\ \btypes \ |\ [\wt{l:\tau}] \ |\ \alpha\ \synwedge\ \alpha \ |\ \synneg\ \alpha
\qquad
& \mbox{{\em Field types} ($\alpha $-types)}
\\
\mu & ::=  & \alpha \to \alpha \ |\ \mu\ \synwedge\ \mu \ |\ \synneg\ \mu
& \mbox{{\em Method types} ($\mu $-types)}
\end{array}
$$

The $\alpha$-types are used to type fields and the $\mu$-types are used to type methods.
Type $\zero$ is the empty type.
Type $\btypes$ denotes the \emph{basic} types, such as integers, booleans, etc.
{Record} types $[\wt{l:\tau}]$, where $\wt l$ is a sequence of disjoint labels, are used to type objects.
Arrow types $\alpha \to \alpha$ are used to type methods.

The boolean connectives $\bf{and}$ and $\bf{not}$ in the $\alpha$-types and $\mu$-types have their expected set-theoretic meanings.
We let $\alpha\ \syndiff\ \alpha'$  denote $\alpha\ \synwedge\ (\synneg\ \alpha')$, and $\alpha\ \synvee\ \alpha'$  denote $\synneg(\synneg\ \alpha\ \synwedge\ (\synneg\ \alpha'))$.

\subsection{Terms}
\label{sec:terms}
The syntax of terms is defined by the following grammar and is based on the standard syntax of terms in FJ \cite{featherweight}:
\begin{align*}
     & \mbox{\textit{Class declaration}}  & L \; ::= \; & \syndecl{C}{C}{\wt{\alpha \ a};\ K; \ \wt{M}\ }                         \\
     & \mbox{\textit{Constructor}}        & K \;::=\;   & C\ (\wt{\alpha\ x})\ \{\ \synsuper(\wt{x});\ \wt{\synthis.a}=\wt{x}; \} \\
     & \mbox{\textit{Method declaration}} & M \; ::= \; & \alpha \ m\ (\alpha \ x)\ \{\ \synret e; \}                             \\
     & \mbox{\textit{Expressions}}        & e \; ::=\;  & x\ |\  c\ |\ e.a\ |\ e.m(e) \ | \ \synnew C(\wt{e})
\end{align*}

We assume an infinite set of names, with some special names:
$\mathit{Object}$ denotes the root class, $\synthis$ denotes the current object and $\synsuper$ denotes the parent object.
We let  $A, B,\ldots$ range over classes; $a, b,\ldots$ over fields; $m, n,\ldots$ over methods and $x, y, z, \ldots$ over variables.

A {program} $(\wt{L}, e)$ is a pair of a sequence of class declarations $\wt L$, giving rise to a class hierarchy as specified by the inheritance relation, and an expression $e$ to be evaluated. 
%
A class declaration $L$ specifies the name of the class, the name of the parent class it extends, its typed fields, the constructor $K$ and its method declarations $M$.
The constructor $K$ initializes the fields of the object by assigning values to the fields inherited by the super-class and to the fields declared in the current \textbf{this} class.
%
A method declaration $M$ specifies the signature of the method, namely the return type, the method name and the formal parameter as well as the body of the method.
Notice that in our theoretical development we use unary methods, without loss of generality: tuples of arguments can be modelled by an object that instantiates a ``special''class containing as fields all the needed arguments.
Expressions $e$ include variables, constants, field accesses, method invocations and object creations.


\paragraph{On multimethods}
Since FJ is a core language, some features of the full Java are removed, such as overloading methods.
In our framework, by leveraging the expressivity of boolean connectives and semantic subtyping, we are able to restore overloading, among other features \cite[\S 8.4]{Dardha2017}.
We can thus model \emph{multimethods}, \cite{BC97}, which according to the authors is ``\emph{very clean and easy to understand [...] it would be the best solution for a brand new language}".
As an example, taken from Dardha \emph{et al.}  \cite{Dardha2013,Dardha2017}, consider the following class declarations:
$$
\begin{array}{ll}
\syndecl{A}{\mathit{Object}} {
&
\qquad
\syndecl{B}{A} {
\\
	%\qquad\quad \ldots
%&
	%\qquad\qquad\quad \ldots
%\\
	\qquad\quad \mathbf{int}\ \mathit{length}\ (\mathbf{string}\ s)\{\ \ldots\ \}\qquad
&
	\qquad\qquad\quad \mathbf{int}\ \mathit{length}\ (\mathbf{int}\ n)\{\ \ldots\ \}
\\
}
&
\qquad }
\end{array}
$$
Method {\it length} has type $\mathbf{string} \rightarrow \mathbf{int}$ in class $A$.
However, because class $B$ extends class $A$,  {\it length} has type $(\mathbf{string} \rightarrow \mathbf{int})\ \synwedge\ (\mathbf{int} \rightarrow \mathbf{int})$ in class $B$,
which can be simplified to $(\mathbf{string}\ \synvee\ \mathbf{int}) \rightarrow \mathbf{int}$.

Following FJ \cite{featherweight}, we rule out ill-formed programs, such as declaring a constructor named $B$ within a class named $A$; or multiple fields or methods having the same name; or fields having the same type as the type of the class they are defined in.

% \subsection{Typing Rules} use the subtyping relation $\leq_{\mathcal B}$ defined semantically as set inclusion of types which are interpreted as subsets of a model, we call it $\mathcal B$ of FJ. Details of model $\mathcal B$ and the subtyping relation $\leq_{\mathcal B}$ are fully presented in \cite{Dardha2013,Dardha2017}.

% Typing judgements for expression are of the form $\Gamma \vdash_{\mathcal B} e : \tau$ and for method declarations are $\Gamma \vdash_{\mathcal B} M$. The same for class declarations and programs.

% Let us assume a sequence of class declarations $\wt{L}$.
% We first determine the (structural) type of every class $C$ in $\wt{L}$.
% To this aim, we have to take into account the inheritance relation specified in the class declarations in $\wt{L}$.
% We write ``$a \in C$'' to mean that there is a field declaration of name $a$ in class $C$ within the hierarchy $\wt L$.
% Similarly, we write ``$a \in C$ with type $\alpha$'' to also specify the declared type $\alpha$. Similar notations also hold for method names $m$.